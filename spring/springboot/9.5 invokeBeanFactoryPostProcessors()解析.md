[TOC]
# 1 invokeBeanFactoryPostProcessors()：主要是解析配置文件

- 对main对应的类进行解析
- 解析依赖类，解析@PropertySource注解，将PropertySource加入environment中的PropertySource中
- 扫描BasePackages，递归继续basePackages对应的类（如main对应的类那样解析）

```java
//AbstractApplicationContext
protected void invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory beanFactory) {
    //1
    PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, this.getBeanFactoryPostProcessors());
    if (beanFactory.getTempClassLoader() == null && beanFactory.containsBean("loadTimeWeaver")) {
        beanFactory.addBeanPostProcessor(new LoadTimeWeaverAwareProcessor(beanFactory));
        beanFactory.setTempClassLoader(new ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));
    }

}
```

```java
//PostProcessorRegistrationDelegate 1.1 
public static void invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory beanFactory, List<BeanFactoryPostProcessor> beanFactoryPostProcessors) {
    Set<String> processedBeans = new HashSet();
    ArrayList regularPostProcessors;
    ArrayList registryProcessors;
    int var9;
    ArrayList currentRegistryProcessors;
    String[] postProcessorNames;
    if (beanFactory instanceof BeanDefinitionRegistry) {
        BeanDefinitionRegistry registry = (BeanDefinitionRegistry)beanFactory;
        regularPostProcessors = new ArrayList();
        registryProcessors = new ArrayList();
        Iterator var6 = beanFactoryPostProcessors.iterator();

        while(var6.hasNext()) {
            BeanFactoryPostProcessor postProcessor = (BeanFactoryPostProcessor)var6.next();
            if (postProcessor instanceof BeanDefinitionRegistryPostProcessor) {
                BeanDefinitionRegistryPostProcessor registryProcessor = (BeanDefinitionRegistryPostProcessor)postProcessor;
                registryProcessor.postProcessBeanDefinitionRegistry(registry);
                registryProcessors.add(registryProcessor);
            } else {
                regularPostProcessors.add(postProcessor);
            }
        }

        currentRegistryProcessors = new ArrayList();
        postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);
        String[] var16 = postProcessorNames;
        var9 = postProcessorNames.length;

        int var10;
        String ppName;
        for(var10 = 0; var10 < var9; ++var10) {
            ppName = var16[var10];
            if (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) {
                currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));
                processedBeans.add(ppName);
            }
        }

        sortPostProcessors(currentRegistryProcessors, beanFactory);
        registryProcessors.addAll(currentRegistryProcessors);
        //2 这里进入配置文件分析
        invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);
        currentRegistryProcessors.clear();
        postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);
        var16 = postProcessorNames;
        var9 = postProcessorNames.length;

        for(var10 = 0; var10 < var9; ++var10) {
            ppName = var16[var10];
            if (!processedBeans.contains(ppName) && beanFactory.isTypeMatch(ppName, Ordered.class)) {
                currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));
                processedBeans.add(ppName);
            }
        }

        sortPostProcessors(currentRegistryProcessors, beanFactory);
        registryProcessors.addAll(currentRegistryProcessors);
        invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);
        currentRegistryProcessors.clear();
        boolean reiterate = true;

        while(reiterate) {
            reiterate = false;
            postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);
            String[] var19 = postProcessorNames;
            var10 = postProcessorNames.length;

            for(int var26 = 0; var26 < var10; ++var26) {
                String ppName = var19[var26];
                if (!processedBeans.contains(ppName)) {
                    currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));
                    processedBeans.add(ppName);
                    reiterate = true;
                }
            }

            sortPostProcessors(currentRegistryProcessors, beanFactory);
            registryProcessors.addAll(currentRegistryProcessors);
            invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);
            currentRegistryProcessors.clear();
        }

        invokeBeanFactoryPostProcessors((Collection)registryProcessors, (ConfigurableListableBeanFactory)beanFactory);
        invokeBeanFactoryPostProcessors((Collection)regularPostProcessors, (ConfigurableListableBeanFactory)beanFactory);
    } else {
        invokeBeanFactoryPostProcessors((Collection)beanFactoryPostProcessors, (ConfigurableListableBeanFactory)beanFactory);
    }

    String[] postProcessorNames = beanFactory.getBeanNamesForType(BeanFactoryPostProcessor.class, true, false);
    regularPostProcessors = new ArrayList();
    registryProcessors = new ArrayList();
    currentRegistryProcessors = new ArrayList();
    postProcessorNames = postProcessorNames;
    int var20 = postProcessorNames.length;

    String ppName;
    for(var9 = 0; var9 < var20; ++var9) {
        ppName = postProcessorNames[var9];
        if (!processedBeans.contains(ppName)) {
            if (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) {
                regularPostProcessors.add(beanFactory.getBean(ppName, BeanFactoryPostProcessor.class));
            } else if (beanFactory.isTypeMatch(ppName, Ordered.class)) {
                registryProcessors.add(ppName);
            } else {
                currentRegistryProcessors.add(ppName);
            }
        }
    }

    sortPostProcessors(regularPostProcessors, beanFactory);
    invokeBeanFactoryPostProcessors((Collection)regularPostProcessors, (ConfigurableListableBeanFactory)beanFactory);
    List<BeanFactoryPostProcessor> orderedPostProcessors = new ArrayList();
    Iterator var21 = registryProcessors.iterator();

    while(var21.hasNext()) {
        String postProcessorName = (String)var21.next();
        orderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor.class));
    }

    sortPostProcessors(orderedPostProcessors, beanFactory);
    invokeBeanFactoryPostProcessors((Collection)orderedPostProcessors, (ConfigurableListableBeanFactory)beanFactory);
    List<BeanFactoryPostProcessor> nonOrderedPostProcessors = new ArrayList();
    Iterator var24 = currentRegistryProcessors.iterator();

    while(var24.hasNext()) {
        ppName = (String)var24.next();
        nonOrderedPostProcessors.add(beanFactory.getBean(ppName, BeanFactoryPostProcessor.class));
    }

    invokeBeanFactoryPostProcessors((Collection)nonOrderedPostProcessors, (ConfigurableListableBeanFactory)beanFactory);
    beanFactory.clearMetadataCache();
}
```

# 2 配置文件分析

```java
//PostProcessorRegistrationDelegate
private static void invokeBeanDefinitionRegistryPostProcessors(Collection<? extends BeanDefinitionRegistryPostProcessor> postProcessors, BeanDefinitionRegistry registry) {
    Iterator var2 = postProcessors.iterator();

    while(var2.hasNext()) {
        BeanDefinitionRegistryPostProcessor postProcessor = (BeanDefinitionRegistryPostProcessor)var2.next();
        postProcessor.postProcessBeanDefinitionRegistry(registry);
    }
}
//ConfigurationClassPostProcessor：关键类
public void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry) {
    int registryId = System.identityHashCode(registry);
    if (this.registriesPostProcessed.contains(registryId)) {
        throw new IllegalStateException("postProcessBeanDefinitionRegistry already called on this post-processor against " + registry);
    } else if (this.factoriesPostProcessed.contains(registryId)) {
        throw new IllegalStateException("postProcessBeanFactory already called on this post-processor against " + registry);
    } else {
        this.registriesPostProcessed.add(registryId);
        //1.1.1.1
        this.processConfigBeanDefinitions(registry);
    }
}
```

# 3 processConfigBeanDefinitions()：正式解析 

- 获取所有已经注册的bean
- 拦截是配置类的bean，得到configCandidates
- 对configCandidates按@Order顺序排序
- 实例化ConfigurationClassParser 为了解析各个配置类 
- 进行解析
  - 调用ConfigurationClassParser#parse进行解析
  - 将解析过的配置类加入到configClasses,并将configClasses去重已经处理过的,以防止重复加载
  - 

```java
public void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {
    List<BeanDefinitionHolder> configCandidates = new ArrayList();
    //1 获取已经注册的bean名称
    String[] candidateNames = registry.getBeanDefinitionNames();
    String[] var4 = candidateNames;
    int var5 = candidateNames.length;

    for(int var6 = 0; var6 < var5; ++var6) {
        String beanName = var4[var6];
        BeanDefinition beanDef = registry.getBeanDefinition(beanName);
        // 如果BeanDefinition 中的configurationClass 属性为full 或者lite ,则意味着已经处理过了,直接跳过
        if (!ConfigurationClassUtils.isFullConfigurationClass(beanDef) && !ConfigurationClassUtils.isLiteConfigurationClass(beanDef)) {
            //3.1 判断对应bean是否为配置类
            if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {
                // 2 判断对应bean是否为配置类,如果是,则加入到configCandidates(关键！)
                configCandidates.add(new BeanDefinitionHolder(beanDef, beanName));
            }
        } else if (this.logger.isDebugEnabled()) {
            this.logger.debug("Bean definition has already been processed as a configuration class: " + beanDef);
        }
    }

    //走到这里，configCandidates中只有一个main对应的类
    if (!configCandidates.isEmpty()) {
        //3 对configCandidates 进行 排序,按照@Order 配置的值进行排序
        configCandidates.sort((bd1, bd2) -> {
            int i1 = ConfigurationClassUtils.getOrder(bd1.getBeanDefinition());
            int i2 = ConfigurationClassUtils.getOrder(bd2.getBeanDefinition());
            return Integer.compare(i1, i2);
        });
        // 如果BeanDefinitionRegistry 是SingletonBeanRegistry 子类的话,由于我们当前传入的是DefaultListableBeanFactory,是SingletonBeanRegistry 的子类。因此会将registry强转为SingletonBeanRegistry
        SingletonBeanRegistry sbr = null;
        if (registry instanceof SingletonBeanRegistry) {
            sbr = (SingletonBeanRegistry)registry;
            if (!this.localBeanNameGeneratorSet) {
                BeanNameGenerator generator = (BeanNameGenerator)sbr.getSingleton("org.springframework.context.annotation.internalConfigurationBeanNameGenerator");
                if (generator != null) {
                    this.componentScanBeanNameGenerator = generator;
                    this.importBeanNameGenerator = generator;
                }
            }
        }
        if (this.environment == null) {
            this.environment = new StandardEnvironment();
        }
		// 4. 实例化ConfigurationClassParser 为了解析 各个配置类
        ConfigurationClassParser parser = new ConfigurationClassParser(this.metadataReaderFactory, this.problemReporter, this.environment, this.resourceLoader, this.componentScanBeanNameGenerator, registry);
        
         // 实例化2个set,candidates 用于将之前加入的configCandidates 进行去重
    	// alreadyParsed 用于判断是否处理过
        Set<BeanDefinitionHolder> candidates = new LinkedHashSet(configCandidates);
        HashSet alreadyParsed = new HashSet(configCandidates.size());
        
		// 5. 进行解析
        do {
            //3.2
            parser.parse(candidates);//解析
            parser.validate();
            //将解析过的配置类加入到configClasses
            Set<ConfigurationClass> configClasses = new LinkedHashSet(parser.getConfigurationClasses());
            //将configClasses去重已经处理过的,以防止重复加载
            configClasses.removeAll(alreadyParsed);
            if (this.reader == null) {
                this.reader = new ConfigurationClassBeanDefinitionReader(registry, this.sourceExtractor, this.resourceLoader, this.environment, this.importBeanNameGenerator, parser.getImportRegistry());
            }
			//调用ConfigurationClassBeanDefinitionReader#loadBeanDefinitions 进行加载
            this.reader.loadBeanDefinitions(configClasses);
            //加入到alreadyParsed中,用于去重
            alreadyParsed.addAll(configClasses);
            candidates.clear();
            //如果registry中注册的bean的数量 大于 之前获得的数量,则意味着在解析过程中又新加入了很多,那么就需要对其进行解析
            if (registry.getBeanDefinitionCount() > candidateNames.length) {
                String[] newCandidateNames = registry.getBeanDefinitionNames();
                Set<String> oldCandidateNames = new HashSet(Arrays.asList(candidateNames));
                Set<String> alreadyParsedClasses = new HashSet();
                Iterator var12 = alreadyParsed.iterator();

                while(var12.hasNext()) {
                    ConfigurationClass configurationClass = (ConfigurationClass)var12.next();
                    alreadyParsedClasses.add(configurationClass.getMetadata().getClassName());
                }

                String[] var23 = newCandidateNames;
                int var24 = newCandidateNames.length;

                for(int var14 = 0; var14 < var24; ++var14) {
                    String candidateName = var23[var14];
                    if (!oldCandidateNames.contains(candidateName)) {
                        BeanDefinition bd = registry.getBeanDefinition(candidateName);
                        if (ConfigurationClassUtils.checkConfigurationClassCandidate(bd, this.metadataReaderFactory) && !alreadyParsedClasses.contains(bd.getBeanClassName())) {
                            candidates.add(new BeanDefinitionHolder(bd, candidateName));
                        }
                    }
                }

                candidateNames = newCandidateNames;
            }
        } while(!candidates.isEmpty());

        if (sbr != null && !sbr.containsSingleton(IMPORT_REGISTRY_BEAN_NAME)) {
            sbr.registerSingleton(IMPORT_REGISTRY_BEAN_NAME, parser.getImportRegistry());
        }

        if (this.metadataReaderFactory instanceof CachingMetadataReaderFactory) {
            ((CachingMetadataReaderFactory)this.metadataReaderFactory).clearCache();
        }

    }
}
```
## 3.1 判断bean是否为配置类，如果是设置Order属性，加入configCandidates

- 获取类名,如果类名不存在则返回false
- 如果存在，则获取MetaData
  -  如果BeanDefinition 是 AnnotatedBeanDefinition的实例,并且className 和 BeanDefinition中 的元数据 的类名相同则直接从BeanDefinition 获得Metadata
  - 如果BeanDefinition 是 AnnotatedBeanDefinition的实例,并且beanDef 有 beanClass 属性存在 则实例化StandardAnnotationMetadata
  - 否则 通过MetadataReaderFactory 中的MetadataReader 进行读取
- 判断MetaData有没有Configuration 注解
  - 如果存在Configuration 注解,则为BeanDefinition 设置configurationClass属性为full
  - 如果AnnotationMetadata 中有Component,ComponentScan,Import,ImportResource 注解中的任意一个,或者存在 被@bean 注解的方法,.则设置configurationClass属性为lite
  - 否则直接返回
- 判断MetaData中有没有Order注解，如果有则设置order属性为@Order的值
- 走到这里返回true，说明是配置类，否则返回false

```java
public static boolean checkConfigurationClassCandidate(BeanDefinition beanDef, MetadataReaderFactory metadataReaderFactory) {
    //1. 获取类名,如果类名不存在则返回false
    String className = beanDef.getBeanClassName();
    if (className != null && beanDef.getFactoryMethodName() == null) {
        Object metadata;
        if (beanDef instanceof AnnotatedBeanDefinition && className.equals(((AnnotatedBeanDefinition)beanDef).getMetadata().getClassName())) {
            //2.1 如果BeanDefinition 是 AnnotatedBeanDefinition的实例,并且className 和 BeanDefinition中 的元数据 的类名相同则直接从BeanDefinition 获得Metadata
            metadata = ((AnnotatedBeanDefinition)beanDef).getMetadata();
        } else if (beanDef instanceof AbstractBeanDefinition && ((AbstractBeanDefinition)beanDef).hasBeanClass()) {
            //2.2 如果BeanDefinition 是 AnnotatedBeanDefinition的实例,并且beanDef 有 beanClass 属性存在 则实例化StandardAnnotationMetadata
            Class<?> beanClass = ((AbstractBeanDefinition)beanDef).getBeanClass();
            metadata = new StandardAnnotationMetadata(beanClass, true);
        } else {
            // 2.3 否则 通过MetadataReaderFactory 中的MetadataReader 进行读取
            try {
                MetadataReader metadataReader = metadataReaderFactory.getMetadataReader(className);
                metadata = metadataReader.getAnnotationMetadata();
            } catch (IOException var5) {
                if (logger.isDebugEnabled()) {
                    logger.debug("Could not find class file for introspecting configuration annotations: " + className, var5);
                }

                return false;
            }
        }
		//3
        if (isFullConfigurationCandidate((AnnotationMetadata)metadata)) {
            // 3.1 如果存在Configuration 注解,则为BeanDefinition 设置configurationClass属性为full
            beanDef.setAttribute(CONFIGURATION_CLASS_ATTRIBUTE, "full");
        } else {
            if (!isLiteConfigurationCandidate((AnnotationMetadata)metadata)) {
                return false;
            }
			//3.2 如果AnnotationMetadata 中有Component,ComponentScan,Import,ImportResource 注解中的任意一个,或者存在 被@bean 注解的方法,则返回true.则设置configurationClass属性为lite
            beanDef.setAttribute(CONFIGURATION_CLASS_ATTRIBUTE, "lite");
        }
        Integer order = getOrder((AnnotationMetadata)metadata);
        if (order != null) {
             // 4. 如果该类被@Order所注解,则设置order属性为@Order的值
            beanDef.setAttribute(ORDER_ATTRIBUTE, order);
        }
        return true;
    } else {
        return false;
    }
}
```
## 3.2 对configCandidates解析

```java
//ConfigurationClassParser
public void parse(Set<BeanDefinitionHolder> configCandidates) {
    Iterator var2 = configCandidates.iterator();

    while(var2.hasNext()) {
        BeanDefinitionHolder holder = (BeanDefinitionHolder)var2.next();
        BeanDefinition bd = holder.getBeanDefinition();

        try {
            if (bd instanceof AnnotatedBeanDefinition) {
                //3.2.1
                this.parse(((AnnotatedBeanDefinition)bd).getMetadata(), holder.getBeanName());
            } else if (bd instanceof AbstractBeanDefinition && ((AbstractBeanDefinition)bd).hasBeanClass()) {
                this.parse(((AbstractBeanDefinition)bd).getBeanClass(), holder.getBeanName());
            } else {
                this.parse(bd.getBeanClassName(), holder.getBeanName());
            }
        } catch (BeanDefinitionStoreException var6) {
            throw var6;
        } catch (Throwable var7) {
            throw new BeanDefinitionStoreException("Failed to parse configuration class [" + bd.getBeanClassName() + "]", var7);
        }
    }
	//3.2.2
    this.deferredImportSelectorHandler.process();
}
```

### 3.2.1 解析

- 判断类是否应该跳过
  - 不应该，则处理Imported的情况
  - 将configclass包装成SourceClass
  - 递归调用进行解析

```java
//ConfigurationClassParser
protected void processConfigurationClass(ConfigurationClass configClass) throws IOException {
    // 1. 判断是否应该被跳过:如果这个类没有被@Conditional注解所修饰，不会skip
    //3.2.1.1
    if (!this.conditionEvaluator.shouldSkip(configClass.getMetadata(), ConfigurationPhase.PARSE_CONFIGURATION)) {
        // 2. 处理Imported 的情况
        ConfigurationClass existingClass = (ConfigurationClass)this.configurationClasses.get(configClass);
        if (existingClass != null) {
            if (configClass.isImported()) {
                if (existingClass.isImported()) {
                    existingClass.mergeImportedBy(configClass);
                }
                return;
            }
            this.configurationClasses.remove(configClass);
            this.knownSuperclasses.values().removeIf(configClass::equals);
        }

        //将configclass包装成SourceClass
        ConfigurationClassParser.SourceClass sourceClass = this.asSourceClass(configClass);
        
        // 3. 递归调用进行解析
        do {
            //3.2.1.2
            sourceClass = this.doProcessConfigurationClass(configClass, sourceClass);
        } while(sourceClass != null);
		
        this.configurationClasses.put(configClass, configClass);
    }
}
```

#### 3.2.1.1 判断类有没有被@Conditional注解

```java
//ConditionEvaluator
public boolean shouldSkip(@Nullable AnnotatedTypeMetadata metadata, @Nullable ConfigurationPhase phase) {
    // 1. 如果这个类没有被@Conditional注解所修饰，不会skip，有要继续判断
    if (metadata != null && metadata.isAnnotated(Conditional.class.getName())) {
        if (phase == null) {
            //是配置类的话直接使用PARSE_CONFIGURATION阶段
            //否则使用REGISTER_BEAN阶段
            return metadata instanceof AnnotationMetadata && ConfigurationClassUtils.isConfigurationCandidate((AnnotationMetadata)metadata) ? this.shouldSkip(metadata, ConfigurationPhase.PARSE_CONFIGURATION) : this.shouldSkip(metadata, ConfigurationPhase.REGISTER_BEAN);
        } else {
            //phase不为null
            List<Condition> conditions = new ArrayList();
            // 3. 获取配置类的条件注解得到条件数据，并添加到集合中
            Iterator var4 = this.getConditionClasses(metadata).iterator();
            while(var4.hasNext()) {
                String[] conditionClasses = (String[])var4.next();
                String[] var6 = conditionClasses;
                int var7 = conditionClasses.length;

                for(int var8 = 0; var8 < var7; ++var8) {
                    String conditionClass = var6[var8];
                    Condition condition = this.getCondition(conditionClass, this.context.getClassLoader());
                    conditions.add(condition);
                }
            }
		   //根据Order排序
            AnnotationAwareOrderComparator.sort(conditions);
            
            // 4. 遍历conditions,进行判断
            var4 = conditions.iterator();
            Condition condition;
            ConfigurationPhase requiredPhase;
            do {
                do {
                    //iterator要判断是否有值了
                    if (!var4.hasNext()) {
                        return false;
                    }
                    condition = (Condition)var4.next();
                    requiredPhase = null;
                    if (condition instanceof ConfigurationCondition) {
                        requiredPhase = ((ConfigurationCondition)condition).getConfigurationPhase();
                    }
                } while(requiredPhase != null && requiredPhase != phase);
            } while(condition.matches(this.context, metadata));
            //只有不满足内/外while，才能出来
            return true;
        }
    } else {
        return false;
    }
}
```

#### 3.2.1.2 如果不是，递归调用进行解析

```java
//ConfigurationClassParser
protected final ConfigurationClassParser.SourceClass doProcessConfigurationClass(ConfigurationClass configClass, ConfigurationClassParser.SourceClass sourceClass) throws IOException {
    if (configClass.getMetadata().isAnnotated(Component.class.getName())) {
        //处理类中的依赖类
        //3.2.1.2.1
        this.processMemberClasses(configClass, sourceClass);
    }

    // 处理@PropertySources注解,解析属性文件
    // 将解析出来的属性资源添加到environment
    Iterator var3 = AnnotationConfigUtils.attributesForRepeatable(sourceClass.getMetadata(), PropertySources.class, PropertySource.class).iterator();
    AnnotationAttributes importResource;
    while(var3.hasNext()) {
        importResource = (AnnotationAttributes)var3.next();
        if (this.environment instanceof ConfigurableEnvironment) {
            //3.2.1.2.2
            this.processPropertySource(importResource);
        } else {
            this.logger.info("Ignoring @PropertySource annotation on [" + sourceClass.getMetadata().getClassName() + "]. Reason: Environment must implement ConfigurableEnvironment");
        }
    }

    //处理@ComponentScan
    Set<AnnotationAttributes> componentScans = AnnotationConfigUtils.attributesForRepeatable(sourceClass.getMetadata(), ComponentScans.class, ComponentScan.class);
    if (!componentScans.isEmpty() && !this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {
        Iterator var13 = componentScans.iterator();

        while(var13.hasNext()) {
            AnnotationAttributes componentScan = (AnnotationAttributes)var13.next();
            //3.2.1.2.3解析basePackages并扫描
            //PersonController/personServiceImpl
            Set<BeanDefinitionHolder> scannedBeanDefinitions = this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());
            Iterator var7 = scannedBeanDefinitions.iterator();

            while(var7.hasNext()) {
                BeanDefinitionHolder holder = (BeanDefinitionHolder)var7.next();
                BeanDefinition bdCand = holder.getBeanDefinition().getOriginatingBeanDefinition();
                if (bdCand == null) {
                    bdCand = holder.getBeanDefinition();
                }
			   //bdcand时full或lite属性就进入
                if (ConfigurationClassUtils.checkConfigurationClassCandidate(bdCand, this.metadataReaderFactory)) {
                    //3.2.1.2.4 递归解析
                    this.parse(bdCand.getBeanClassName(), holder.getBeanName());
                }
            }
        }
    }

    //处理@Import
    //3.2.1.2.5
    this.processImports(configClass, sourceClass, this.getImports(sourceClass), true);
    
    //处理@ImportResource
    //3.2.1.2.6
    importResource = AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class);
    if (importResource != null) {
        // 遍历配置的locations,加入到configClass 中的ImportedResource
        String[] resources = importResource.getStringArray("locations");
        Class<? extends BeanDefinitionReader> readerClass = importResource.getClass("reader");
        String[] var19 = resources;
        int var21 = resources.length;

        for(int var22 = 0; var22 < var21; ++var22) {
            String resource = var19[var22];
            String resolvedResource = this.environment.resolveRequiredPlaceholders(resource);
            configClass.addImportedResource(resolvedResource, readerClass);
        }
    }
	
    //处理@Bean注解：获取被@Bean注解修饰的方法，然后添加到配置类的beanMethods属性中
    //3.2.1.2.7
    Set<MethodMetadata> beanMethods = this.retrieveBeanMethodMetadata(sourceClass);
    Iterator var17 = beanMethods.iterator();
    while(var17.hasNext()) {
        MethodMetadata methodMetadata = (MethodMetadata)var17.next();
        configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));
    }
	//接口
    //3.2.1.2.8
    this.processInterfaces(configClass, sourceClass);
    //如果有父类的话,则返回父类进行进一步的解析
    if (sourceClass.getMetadata().hasSuperClass()) {
        String superclass = sourceClass.getMetadata().getSuperClassName();
        if (superclass != null && !superclass.startsWith("java") && !this.knownSuperclasses.containsKey(superclass)) {
            this.knownSuperclasses.put(superclass, configClass);
            return sourceClass.getSuperClass();//return不为null，则不跳过最外层的循环，继续解析父类！
        }
    }

    return null;//走到这里，才跳过外层循环
}
```

##### 3.2.1.2.1 处理类中的依赖类（递归解析，这里发现循环依赖！！）

- 遍历class中的内部类
- 如果importStack 包含该configClass的话,则意味发生了循环依赖,则会抛出BeanDefinitionParsingException 异常
- 否则加入到importStack
- 调用processConfigurationClass 进行解析，3.2.1 解析（递归了）

```java
//ConfigurationClassParser
private void processMemberClasses(ConfigurationClass configClass, ConfigurationClassParser.SourceClass sourceClass) throws IOException {
    Collection<ConfigurationClassParser.SourceClass> memberClasses = sourceClass.getMemberClasses();
    if (!memberClasses.isEmpty()) {
        List<ConfigurationClassParser.SourceClass> candidates = new ArrayList(memberClasses.size());
        // 1. 遍历class中的内部类
        Iterator var5 = memberClasses.iterator();
        ConfigurationClassParser.SourceClass candidate;
        while(var5.hasNext()) {
            candidate = (ConfigurationClassParser.SourceClass)var5.next();
            // 2. 如果该内部类是一个配置类,并且该内部类的类名和configClass的类名不相同
            if (ConfigurationClassUtils.isConfigurationCandidate(candidate.getMetadata()) && !candidate.getMetadata().getClassName().equals(configClass.getMetadata().getClassName())) {
                candidates.add(candidate);
            }
        }
		//按Order排序
        OrderComparator.sort(candidates);
        //遍历候选的
        var5 = candidates.iterator();
        while(var5.hasNext()) {
            candidate = (ConfigurationClassParser.SourceClass)var5.next();
            // 2.1 如果importStack 包含该configClass的话,则意味发生了循环依赖,则会抛出BeanDefinitionParsingException 异常
            if (this.importStack.contains(configClass)) {
                this.problemReporter.error(new ConfigurationClassParser.CircularImportProblem(configClass, this.importStack));
            } else {
                //否则加入到importStack
                this.importStack.push(configClass);
                try {
                    //2.2调用processConfigurationClass 进行解析，3.2.1 解析（递归了）
                    //递归push，当importStack有值时，肯定发生循环依赖
                    this.processConfigurationClass(candidate.asConfigClass(configClass));
                } finally {
                    this.importStack.pop();
                }
            }
        }
    }
}
```

##### 3.2.1.2.2 处理@PropertySource注解

- 解析name,encoding,locations,ignoreResourceNotFound
- 解析factory,用来根据前面的解析值创建propertySource
- 对location进行SPEL表达式的解析
- 将资源加入environment中的propertySource中

```java
private void processPropertySource(AnnotationAttributes propertySource) throws IOException {
    //解析name
    String name = propertySource.getString("name");
    if (!StringUtils.hasLength(name)) {
        name = null;
    }
    //解析encoding
    String encoding = propertySource.getString("encoding");
    if (!StringUtils.hasLength(encoding)) {
        encoding = null;
    }
	//解析路径
    String[] locations = propertySource.getStringArray("value");
    Assert.isTrue(locations.length > 0, "At least one @PropertySource(value) location is required");
    //解析ignoreResourceNotFound属性，如果为true，找不到资源不报错
    boolean ignoreResourceNotFound = propertySource.getBoolean("ignoreResourceNotFound");
    
    //解析factory,用来根据前面的解析值创建propertySource
    Class<? extends PropertySourceFactory> factoryClass = propertySource.getClass("factory");
    //如果该值没有配置，默认为PropertySourceFactory则直接实例化DefaultPropertySourceFactory类，否则开始实例化自定义的类
    PropertySourceFactory factory = factoryClass == PropertySourceFactory.class ? DEFAULT_PROPERTY_SOURCE_FACTORY : (PropertySourceFactory)BeanUtils.instantiateClass(factoryClass);
    
    //遍历路径
    String[] var8 = locations;
    int var9 = locations.length;
    for(int var10 = 0; var10 < var9; ++var10) {
        String location = var8[var10];
        try {
            //对location进行SPEL表达式的解析。比如当前的配置环境中有一个属性为app=shareniu，我们配置的location为${app}最终值为shareniu。通过这里的处理逻辑可以知道location支持多环境的切换以及表达式的配置
            String resolvedLocation = this.environment.resolveRequiredPlaceholders(location);
            //加载资源
            Resource resource = this.resourceLoader.getResource(resolvedLocation);
            //将资源加入environment中的propertySource中！！
            this.addPropertySource(factory.createPropertySource(name, new EncodedResource(resource, encoding)));
        } catch (FileNotFoundException | UnknownHostException | IllegalArgumentException var14) {
            //如果为true，找不到资源不报错
            if (!ignoreResourceNotFound) {
                throw var14;
            }
            if (this.logger.isInfoEnabled()) {
                this.logger.info("Properties location [" + location + "] not resolvable: " + var14.getMessage());
            }
        }
    }
}
```

##### 3.2.1.2.3 扫描basePackages，得到其下的类

- 遍历basePackages,通过findCandidateComponents方法扫描basePackage路径下的java文件
- 如果扫描到文件的话,则遍历之 
  - 解析scope属性：singleton等
  - 生成beanName 
  - 如果该 BeanDefinition 是AbstractBeanDefinition 的子类的话,则调用postProcessBeanDefinition为其设置默认值 
  - 如果该BeanDefinition是AnnotatedBeanDefinition的子类,则调用AnnotationConfigUtils#processCommonDefinitionAnnotations,检查常用注解:如lazy等
  - 检查当前bean是否已经注册,如果没有注册的话,则 
    - 生成BeanDefinitionHolder
    - 如果当前bean是用于生成代理的bean那么需要进一步处理 
    - 添加到beanDefinitions中
    - 向BeanDefinitionRegistry进行注册
- 依次遍历扫描的配置类进行递归解析.最终又会调用ConfigurationClassParser#processConfigurationClass

```java
//ClassPathBeanDefinitionScanner
//之前已经解析处了basePackages了
protected Set<BeanDefinitionHolder> doScan(String... basePackages) {
    Assert.notEmpty(basePackages, "At least one base package must be specified");
    Set<BeanDefinitionHolder> beanDefinitions = new LinkedHashSet();
    String[] var3 = basePackages;
    int var4 = basePackages.length;

    for(int var5 = 0; var5 < var4; ++var5) {
        String basePackage = var3[var5];
        //找到basePackage下的类：personController,personServiceImpl
        //3.2.1.2.3.1
        Set<BeanDefinition> candidates = this.findCandidateComponents(basePackage);
        Iterator var8 = candidates.iterator();
        while(var8.hasNext()) {
            BeanDefinition candidate = (BeanDefinition)var8.next();
            // 解析scope属性：一般为singleton
            ScopeMetadata scopeMetadata = this.scopeMetadataResolver.resolveScopeMetadata(candidate);
            candidate.setScope(scopeMetadata.getScopeName());
            //beanNameGenerator生成BeanName
            String beanName = this.beanNameGenerator.generateBeanName(candidate, this.registry);
            // 普通的BeanDefinition
            if (candidate instanceof AbstractBeanDefinition) {
                //设置candidate的beanDefinition的默认属性：isLazyInit、getAutowireMode等
                this.postProcessBeanDefinition((AbstractBeanDefinition)candidate, beanName);
            }
             // 注解的BeanDefinition，处理注解@Primary、@DependsOn等Bean注解
			//如果是AnnotatedBeanDefinition类型,设置正真属性：setLazyInit、setPrimary、setDependsOn等
            if (candidate instanceof AnnotatedBeanDefinition) {
                AnnotationConfigUtils.processCommonDefinitionAnnotations((AnnotatedBeanDefinition)candidate);
            }
 			// 检查当前bean是否已经注册（BeanFactory中是否包含此BeanDefinition）
            if (this.checkCandidate(beanName, candidate)) {
                //如果没有
                BeanDefinitionHolder definitionHolder = new BeanDefinitionHolder(candidate, beanName);
                //如果当前bean是用于生成代理的bean那么需要进一步处理
                definitionHolder = AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, this.registry);
                //加入beanDefinitions
                beanDefinitions.add(definitionHolder);
                //将beanDefinition信息注册到相关map中
                this.registerBeanDefinition(definitionHolder, this.registry);
            }
        }
    }
    return beanDefinitions;
}
```

###### 3.2.1.2.3.1 找到包下的beanDefinition：默认路径为'classpath\*:\*\*/\*.class'

```java
//ClassPathScanningCandidateComponentProvider
private Set<BeanDefinition> scanCandidateComponents(String basePackage) {
    // 创建存储扫描到的类的集合
    LinkedHashSet candidates = new LinkedHashSet();

    try {
        // 默认的包路径：this.resourcePattern=” **/*.class”，  
        // resolveBasePackage方法将包名中的”.”转换为文件系统的”/”
        String packageSearchPath = "classpath*:" + this.resolveBasePackage(basePackage) + '/' + this.resourcePattern;
        // 循环获取到的资源文件
        Resource[] resources = this.getResourcePatternResolver().getResources(packageSearchPath);
        boolean traceEnabled = this.logger.isTraceEnabled();
        boolean debugEnabled = this.logger.isDebugEnabled();
        Resource[] var7 = resources;
        int var8 = resources.length;
        for(int var9 = 0; var9 < var8; ++var9) {
            Resource resource = var7[var9];
            if (traceEnabled) {
                this.logger.trace("Scanning " + resource);
            }
            if (resource.isReadable()) {
                try {
                    //为指定资源获取元数据读取器，元信息读取器通过汇编(ASM)读//取资源元信息
                    MetadataReader metadataReader = this.getMetadataReaderFactory().getMetadataReader(resource);
                    //如果扫描到的类符合容器配置的过滤规则  
                    if (this.isCandidateComponent(metadataReader)) {
                        //通过汇编(ASM)读取资源字节码中的Bean定义元信息
                        ScannedGenericBeanDefinition sbd = new ScannedGenericBeanDefinition(metadataReader);
                        //设置Bean定义来源于resource 
                        sbd.setResource(resource);
                        //为元数据元素设置配置资源对象  
                        sbd.setSource(resource);
                        //检查Bean是否是一个可实例化的对象
                        if (this.isCandidateComponent((AnnotatedBeanDefinition)sbd)) {
                            if (debugEnabled) {
                                this.logger.debug("Identified candidate component class: " + resource);
                            }

                            candidates.add(sbd);
                        } else if (debugEnabled) {
                            this.logger.debug("Ignored because not a concrete top-level class: " + resource);
                        }
                    } else if (traceEnabled) {
                        this.logger.trace("Ignored because not matching any filter: " + resource);
                    }
                } catch (Throwable var13) {
                    throw new BeanDefinitionStoreException("Failed to read candidate component class: " + resource, var13);
                }
            } else if (traceEnabled) {
                this.logger.trace("Ignored because not readable: " + resource);
            }
        }
        return candidates;
    } catch (IOException var14) {
        throw new BeanDefinitionStoreException("I/O failure during classpath scanning", var14);
    }
}
```

##### 3.2.1.2.4 递归解析扫描到的类

```java
//ConfigurationClassParser
protected final void parse(@Nullable String className, String beanName) throws IOException {
    Assert.notNull(className, "No bean class name for configuration class bean definition");
    MetadataReader reader = this.metadataReaderFactory.getMetadataReader(className);
    //3.2.1 递归解析该类（将personController又看成main对应的类）
    this.processConfigurationClass(new ConfigurationClass(reader, beanName));
}
```

##### 3.2.1.2.5 处理@Import注解

```java
//ConfigurationClassParser
this.processImports(configClass, sourceClass, this.getImports(sourceClass), true);
//首先调用getImports返回目标类中所有的@import注解属性
//然后处理目标类的所有@import注解
```

###### 3.2.1.2.5.1 递归得到所有@import注解

```java
//ConfigurationClassParser
private Set<ConfigurationClassParser.SourceClass> getImports(ConfigurationClassParser.SourceClass sourceClass) throws IOException {
    Set<ConfigurationClassParser.SourceClass> imports = new LinkedHashSet();
    Set<ConfigurationClassParser.SourceClass> visited = new LinkedHashSet();
    this.collectImports(sourceClass, imports, visited);
    return imports;
}
//ConfigurationClassParser
private void collectImports(ConfigurationClassParser.SourceClass sourceClass, Set<ConfigurationClassParser.SourceClass> imports, Set<ConfigurationClassParser.SourceClass> visited) throws IOException {
    if (visited.add(sourceClass)) {
        //得到注解
        Iterator var4 = sourceClass.getAnnotations().iterator();

        while(var4.hasNext()) {
            ConfigurationClassParser.SourceClass annotation = (ConfigurationClassParser.SourceClass)var4.next();
            String annName = annotation.getMetadata().getClassName();
            if (!annName.startsWith("java") && !annName.equals(Import.class.getName())) {
                //递归处理注解的注解
                this.collectImports(annotation, imports, visited);
            }
        }
        //所有的都加入
        imports.addAll(sourceClass.getAnnotationAttributes(Import.class.getName(), "value"));
    }

}
```

###### 3.2.1.2.5.2 处理递归得到所有@import注解

```java
private void processImports(ConfigurationClass configClass, ConfigurationClassParser.SourceClass currentSourceClass, Collection<ConfigurationClassParser.SourceClass> importCandidates, boolean checkForCircularImports) {
    if (!importCandidates.isEmpty()) {
        //循环Import依赖
        if (checkForCircularImports && this.isChainedImportOnStack(configClass)) {
            this.problemReporter.error(new ConfigurationClassParser.CircularImportProblem(configClass, this.importStack));
        } else {
            this.importStack.push(configClass);
			//遍历这些@Import注解内部的属性类集合ComponentScanAnnotationParser
            try {
                Iterator var5 = importCandidates.iterator();

                while(var5.hasNext()) {
                    ConfigurationClassParser.SourceClass candidate = (ConfigurationClassParser.SourceClass)var5.next();
                    Class candidateClass;
                    //如果这个类是个ImportSelector接口的实现类
                    if (candidate.isAssignable(ImportSelector.class)) {
                        candidateClass = candidate.loadClass();
                        // 实例化这个ImportSelector
                        ImportSelector selector = (ImportSelector)BeanUtils.instantiateClass(candidateClass, ImportSelector.class);
                        //这是干啥：
                        ParserStrategyUtils.invokeAwareMethods(selector, this.environment, this.resourceLoader, this.registry);
                        // 如果这个类也是DeferredImportSelector接口的实现类，
                        // 那么加入ConfigurationClassParser的deferredImportSelectors
                        if (selector instanceof DeferredImportSelector) {
                            this.deferredImportSelectorHandler.handle(configClass, (DeferredImportSelector)selector);
                        } else {
                            // 否则调用ImportSelector的selectImports方法得到需要Import的类
                        	// 然后对这些类递归做@Import注解的处理
                            String[] importClassNames = selector.selectImports(currentSourceClass.getMetadata());
                            //包装成类
                            Collection<ConfigurationClassParser.SourceClass> importSourceClasses = this.asSourceClasses(importClassNames);
                            //递归解析Import注解
                            this.processImports(configClass, currentSourceClass, importSourceClasses, false);
                        }
                    } 
                    // 如果这个类是ImportBeanDefinitionRegistrar接口的实现类
                	// 设置到配置类的importBeanDefinitionRegistrars属性中
                    else if (candidate.isAssignable(ImportBeanDefinitionRegistrar.class)) {
                        candidateClass = candidate.loadClass();
                        ImportBeanDefinitionRegistrar registrar = (ImportBeanDefinitionRegistrar)BeanUtils.instantiateClass(candidateClass, ImportBeanDefinitionRegistrar.class);
                        ParserStrategyUtils.invokeAwareMethods(registrar, this.environment, this.resourceLoader, this.registry);
                        configClass.addImportBeanDefinitionRegistrar(registrar, currentSourceClass.getMetadata());
                    } else {
                         // 其它情况下把这个类入队到ConfigurationClassParser的importStack(队列)属性中
                    	// 然后把这个类当成是@Configuration注解修饰的类递归重头开始解析这个类
                        this.importStack.registerImport(currentSourceClass.getMetadata(), candidate.getMetadata().getClassName());
                        this.processConfigurationClass(candidate.asConfigClass(configClass));
                    }
                }
            } catch (BeanDefinitionStoreException var15) {
                throw var15;
            } catch (Throwable var16) {
                throw new BeanDefinitionStoreException("Failed to process import candidates for configuration class [" + configClass.getMetadata().getClassName() + "]", var16);
            } finally {
                this.importStack.pop();
            }
        }

    }
}
```