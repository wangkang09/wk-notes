[TOC]
# 1 invokeBeanFactoryPostProcessors()：主要是解析配置文件

- 获取到了3个后置处理器：SharedMetadataReaderFactoryContextInitializer、ConfigurationWarningsApplicationContextInitializer、ConfigFileApplicationListener

```java
//AbstractApplicationContext
//分类并排序所有的BeanDefinitionRegistry(这里并没有注册，要到下一个方法)
//这里查找了业务类、自动配置类
//具体的单独分析：https://blog.csdn.net/liaokailin/article/details/49107209
//https://blog.csdn.net/qq_26000415/article/details/78917682
//https://www.cnblogs.com/jiaoqq/p/7678037.html
//https://www.jianshu.com/p/b61809506d0b
protected void invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory beanFactory) {
    //1.1 
    PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, this.getBeanFactoryPostProcessors());
    //加载loadTimeWeaver这个类：不知道干啥
    //转载两个PostProcessor,一般不进来
    if (beanFactory.getTempClassLoader() == null && beanFactory.containsBean("loadTimeWeaver")) {
        beanFactory.addBeanPostProcessor(new LoadTimeWeaverAwareProcessor(beanFactory));
        beanFactory.setTempClassLoader(new ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));
    }

}
```
## 1.1 invokeBeanFactoryPostProcessors

- 遍历调用3种PostProcessors：SharedMetadataReaderFactoryContextInitializer、ConfigurationWarningsApplicationContextInitializer、ConfigFileApplicationListener
- 分类遍历        postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);
  - 解析     invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);//这里的currentRegistryProcessors有好几种类型
  - 解析     invokeBeanFactoryPostProcessors((Collection)registryProcessors, (ConfigurableListableBeanFactory)beanFactory);
  - 解析     invokeBeanFactoryPostProcessors((Collection)regularPostProcessors, (ConfigurableListableBeanFactory)beanFactory);

```java
//PostProcessorRegistrationDelegate：遍历调用3种PostProcessors
public static void invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory beanFactory, List<BeanFactoryPostProcessor> beanFactoryPostProcessors) {
    Set<String> processedBeans = new HashSet();
    ArrayList regularPostProcessors;
    ArrayList registryProcessors;
    int var9;
    ArrayList currentRegistryProcessors;
    String[] postProcessorNames;
    if (beanFactory instanceof BeanDefinitionRegistry) {
        BeanDefinitionRegistry registry = (BeanDefinitionRegistry)beanFactory;
        regularPostProcessors = new ArrayList();
        registryProcessors = new ArrayList();
        Iterator var6 = beanFactoryPostProcessors.iterator();

        while(var6.hasNext()) {
            BeanFactoryPostProcessor postProcessor = (BeanFactoryPostProcessor)var6.next();
            if (postProcessor instanceof BeanDefinitionRegistryPostProcessor) {
                BeanDefinitionRegistryPostProcessor registryProcessor = (BeanDefinitionRegistryPostProcessor)postProcessor;
                //将beanFactory信息放置到这个registryProcessor，方便为以后注册
                registryProcessor.postProcessBeanDefinitionRegistry(registry);
                //这里有2个：SharedMetadataReaderFactoryContextInitializer、		ConfigurationWarningsApplicationContextInitializer
                registryProcessors.add(registryProcessor);
            } else {
                //这里有1个 ：ConfigFileApplicationListener
                regularPostProcessors.add(postProcessor);
            }
        }

        currentRegistryProcessors = new ArrayList();
        //第1次获取-------------------
        //从7个beanDefinitionNames中获取匹配的，只要到一个为：internalConfigurationAnnotationProcessor
        postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);
        String[] var16 = postProcessorNames;
        var9 = postProcessorNames.length;
        int var10;
        String ppName;
        for(var10 = 0; var10 < var9; ++var10) {
            ppName = var16[var10];
            //只有满足PriorityOrdered的才会被放入processedBeans
            if (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) {
                currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));
                processedBeans.add(ppName);
            }
        }
		//排序currentRegistryProcessors：只有一个元素：configurationClassPostProcessor
        sortPostProcessors(currentRegistryProcessors, beanFactory);
        registryProcessors.addAll(currentRegistryProcessors);
        //第1次解析-------------------满足PriorityOrdered
        //internalConfigurationAnnotationProcessor满足PriorityOrdered
        //currentRegistryProcessors为：configurationClassPostProcessor
        //2 最重要的一步：解析配置文件！！后面两次都没有进入
        invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);
        //清除
        currentRegistryProcessors.clear();
        
        
        //第2次获取-------------------
        postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);
        var16 = postProcessorNames;
        var9 = postProcessorNames.length;
        for(var10 = 0; var10 < var9; ++var10) {
            ppName = var16[var10];
            //如果ppName对应的不是PriorityOrdered，就不存在
            if (!processedBeans.contains(ppName) && beanFactory.isTypeMatch(ppName, Ordered.class)) {
                currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));
                processedBeans.add(ppName);
            }
        }
        sortPostProcessors(currentRegistryProcessors, beanFactory);
        registryProcessors.addAll(currentRegistryProcessors);
        //第2次解析-------------------满足Ordered
        //currentRegistryProcessors=0，没有作用
        invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);
        currentRegistryProcessors.clear();
        
        boolean reiterate = true;
        while(reiterate) {
            reiterate = false;
        	//第3次获取-------------------
            postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);
            String[] var19 = postProcessorNames;
            var10 = postProcessorNames.length;

            for(int var26 = 0; var26 < var10; ++var26) {
                String ppName = var19[var26];
                //不为PriorityOrdered和Ordered就不存在
                if (!processedBeans.contains(ppName)) {
                    currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));
                    processedBeans.add(ppName);
                    //如果有的话，while不退出
                    reiterate = true;
                }
            }
            sortPostProcessors(currentRegistryProcessors, beanFactory);
            registryProcessors.addAll(currentRegistryProcessors);
        	//第3次解析-------------------不满足Ordered和PriorityOrdered
            //currentRegistryProcessors=0，没有作用
            invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);
            currentRegistryProcessors.clear();
        }
        
		//每次获取postProcessorNames都会将解析出的currentRegistryProcessors放入registryProcessors
        //不同于解析的方法
        //3：解析registryProcessors，原始的registryProcessors就有2个了
        invokeBeanFactoryPostProcessors((Collection)registryProcessors, (ConfigurableListableBeanFactory)beanFactory);
        //如果beanFactoryPostProcessors中有不是BeanDefinitionRegistryPostProcessor的后置处理器，将放入regularPostProcessors中，这里有1个：ConfigFileApplicationListener
        invokeBeanFactoryPostProcessors((Collection)regularPostProcessors, (ConfigurableListableBeanFactory)beanFactory);
    } else {
        //如果不是：beanFactory instanceof BeanDefinitionRegistry 
        invokeBeanFactoryPostProcessors((Collection)beanFactoryPostProcessors, (ConfigurableListableBeanFactory)beanFactory);
    }

    //第1次获取-------------------BeanFactoryPostProcessor!
    //这里获取的是之前获取的父集因为：BeanDefinitionRegistryPostProcessor extends BeanFactoryPostProcessor
    //这里有5个：
    String[] postProcessorNames = beanFactory.getBeanNamesForType(BeanFactoryPostProcessor.class, true, false);
    regularPostProcessors = new ArrayList();
    registryProcessors = new ArrayList();
    currentRegistryProcessors = new ArrayList();
    postProcessorNames = postProcessorNames;
    int var20 = postProcessorNames.length;
	
    String ppName;
    for(var9 = 0; var9 < var20; ++var9) {
        ppName = postProcessorNames[var9];
        //除去之前BeanDefinitionRegistryPostProcessor加入的
        if (!processedBeans.contains(ppName)) {
            if (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) {
                regularPostProcessors.add(beanFactory.getBean(ppName, BeanFactoryPostProcessor.class));
            } else if (beanFactory.isTypeMatch(ppName, Ordered.class)) {
                registryProcessors.add(ppName);
            } else {
                currentRegistryProcessors.add(ppName);
            }
        }
    }
    sortPostProcessors(regularPostProcessors, beanFactory);
    //a 解析regularPostProcessors----------一个：PropertySourcesPlacehoderConfigurer
    //替换174BeanDefinition中的占位符
    invokeBeanFactoryPostProcessors((Collection)regularPostProcessors, (ConfigurableListableBeanFactory)beanFactory);
    
    List<BeanFactoryPostProcessor> orderedPostProcessors = new ArrayList();
    Iterator var21 = registryProcessors.iterator();
    while(var21.hasNext()) {
        String postProcessorName = (String)var21.next();
        orderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor.class));
    }
    sortPostProcessors(orderedPostProcessors, beanFactory);
	//b 解析registryProcessors也即orderedPostProcessors----------没有
    invokeBeanFactoryPostProcessors((Collection)orderedPostProcessors, (ConfigurableListableBeanFactory)beanFactory);
    
    List<BeanFactoryPostProcessor> nonOrderedPostProcessors = new ArrayList();
    Iterator var24 = currentRegistryProcessors.iterator();
    while(var24.hasNext()) {
        ppName = (String)var24.next();
        nonOrderedPostProcessors.add(beanFactory.getBean(ppName, BeanFactoryPostProcessor.class));
    }
    //c 解析currentRegistryProcessors也即nonOrderedPostProcessors----------
    //遍历174个设置beansFactoryMetadata
    invokeBeanFactoryPostProcessors((Collection)nonOrderedPostProcessors, (ConfigurableListableBeanFactory)beanFactory);
    //清楚缓存
    beanFactory.clearMetadataCache();
}
```

# 2 invokeBeanDefinitionRegistryPostProcessors：配置文件分析

```java
//1.1.1 PostProcessorRegistrationDelegate: 最重要的一步：解析配置文件！！
//这里的postProcessors为：ConfigurationClassPostProcessor!
private static void invokeBeanDefinitionRegistryPostProcessors(Collection<? extends BeanDefinitionRegistryPostProcessor> postProcessors, BeanDefinitionRegistry registry) {
    Iterator var2 = postProcessors.iterator();

    while(var2.hasNext()) {
        BeanDefinitionRegistryPostProcessor postProcessor = (BeanDefinitionRegistryPostProcessor)var2.next();
        //关键：
        postProcessor.postProcessBeanDefinitionRegistry(registry);
    }
}
//ConfigurationClassPostProcessor：关键类
public void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry) {
    int registryId = System.identityHashCode(registry);
    if (this.registriesPostProcessed.contains(registryId)) {
        throw new IllegalStateException("postProcessBeanDefinitionRegistry already called on this post-processor against " + registry);
    } else if (this.factoriesPostProcessed.contains(registryId)) {
        throw new IllegalStateException("postProcessBeanFactory already called on this post-processor against " + registry);
    } else {
        this.registriesPostProcessed.add(registryId);
        //3：正式解析
        this.processConfigBeanDefinitions(registry);
    }
}
```

# 2-3 processConfigBeanDefinitions()：正式解析—关键！-从main对应的类开始 

- 获取所有已经注册的bean：7个，解析前的bean：candidateNames
- 遍历candidateNames，拦截是配置类的bean，得到configCandidates：1个：main对应的类
- 对configCandidates按@Order顺序排序
- 实例化一个ConfigurationClassParser 为了解析各个配置类 
- 递归解析
  - 解析本轮的candidates（第一轮就是configCandidates，及main对应的类）
    - 每个candidates内部要经过如下的解析流程
    - 处理嵌套的MemberClass
    - 处理@PropertySource标签，用来解析属性文件并设置到Environment中。
    - 处理@ComponentScan标签，扫描package下的所有Class并进行迭代解析。
    - 处理@Import标签。
    - 处理@ImportResource标签。
    - 处理@Bean标签。
    - 处理所有继承的Interface上的@Bean标签。
    - 处理SuperClass。
    - 处理标签中的DeferredImport。
  - **解析得到对应的所有的配置类configClasses—一个main对应的类会解析出许多其他的配置类**
  - 使用loadBeanDefinitions 对configClasses进行加载
  - 将configClasses加入已解析列表：alreadyParsed
  - 判断解析后的bean是否多于解析前的candidateNames
    - 如果是，说明有新的待解析的candidates
    - 如果不是，递归解析结束

```java
//以下所有的基础类就是：ConfigurationClassPostProcessor，是通过这个类解析的
public void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {
    List<BeanDefinitionHolder> configCandidates = new ArrayList();
    //1 获取已经注册的bean名称：7个
    String[] candidateNames = registry.getBeanDefinitionNames();
    String[] var4 = candidateNames;
    int var5 = candidateNames.length;

    //  ----------------------获取一个configCandidates
    for(int var6 = 0; var6 < var5; ++var6) {
        String beanName = var4[var6];
        BeanDefinition beanDef = registry.getBeanDefinition(beanName);
        // 如果BeanDefinition 中的configurationClass 属性为full 或者lite ,则意味着已经处理过了,直接跳过
        if (!ConfigurationClassUtils.isFullConfigurationClass(beanDef) && !ConfigurationClassUtils.isLiteConfigurationClass(beanDef)) {
            //3.1 判断对应bean是否为配置类
            if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {
                // 2 判断对应bean是否为配置类,如果是,则加入到configCandidates(关键！)
                //7个bean中只有一个是配置类：就是main对于的类
                configCandidates.add(new BeanDefinitionHolder(beanDef, beanName));
            }
        } else if (this.logger.isDebugEnabled()) {
            this.logger.debug("Bean definition has already been processed as a configuration class: " + beanDef);
        }
    }

    //走到这里，configCandidates中只有一个main对应的类
    //这个if一直到最后
    if (!configCandidates.isEmpty()) {
        //3 对configCandidates 进行 排序,按照@Order 配置的值进行排序
        configCandidates.sort((bd1, bd2) -> {
            int i1 = ConfigurationClassUtils.getOrder(bd1.getBeanDefinition());
            int i2 = ConfigurationClassUtils.getOrder(bd2.getBeanDefinition());
            return Integer.compare(i1, i2);
        });
        // 如果BeanDefinitionRegistry 是SingletonBeanRegistry 子类的话,由于我们当前传入的是DefaultListableBeanFactory,是SingletonBeanRegistry 的子类。
        //因此会将registry强转为SingletonBeanRegistry
        SingletonBeanRegistry sbr = null;
        if (registry instanceof SingletonBeanRegistry) {
            sbr = (SingletonBeanRegistry)registry;
            if (!this.localBeanNameGeneratorSet) {
                BeanNameGenerator generator = (BeanNameGenerator)sbr.getSingleton("org.springframework.context.annotation.internalConfigurationBeanNameGenerator");
                if (generator != null) {
                    this.componentScanBeanNameGenerator = generator;
                    this.importBeanNameGenerator = generator;
                }
            }
        }
        if (this.environment == null) {
            this.environment = new StandardEnvironment();
        }
		// ----------------------实例化ConfigurationClassParser 为了解析 各个配置类
        ConfigurationClassParser parser = new ConfigurationClassParser(this.metadataReaderFactory, this.problemReporter, this.environment, this.resourceLoader, this.componentScanBeanNameGenerator, registry);
        
          // 实例化2个set
         //candidates：放置需要解析的类
    	// alreadyParsed：放置已经解析过的类
        Set<BeanDefinitionHolder> candidates = new LinkedHashSet(configCandidates);
        HashSet alreadyParsed = new HashSet(configCandidates.size());
        
		//------------------------ 进行递归解析
        do {
            //3.2 解析一个main类，并得到其他的配置类
            parser.parse(candidates);//解析
            parser.validate();
            //将解析过的配置类加入到configClasses
            Set<ConfigurationClass> configClasses = new LinkedHashSet(parser.getConfigurationClasses());
            //将configClasses去重已经处理过的,以防止重复加载
            configClasses.removeAll(alreadyParsed);
            if (this.reader == null) {
                this.reader = new ConfigurationClassBeanDefinitionReader(registry, this.sourceExtractor, this.resourceLoader, this.environment, this.importBeanNameGenerator, parser.getImportRegistry());
            }
			//调用ConfigurationClassBeanDefinitionReader#loadBeanDefinitions 进行加载
            //3.3
            this.reader.loadBeanDefinitions(configClasses);
            //---------------将已经解析过的bean加入alreadyParsed
            alreadyParsed.addAll(configClasses);
            candidates.clear();
            //如果registry中注册的bean的数量 大于 之前获得的数量,则意味着在解析过程中又新加入了很多,那么就需要对其进行解析
            //candidateNames一开始是7个，随着递归解析会越来越多
            if (registry.getBeanDefinitionCount() > candidateNames.length) {
                //解析后的bean
                String[] newCandidateNames = registry.getBeanDefinitionNames();
                //解析前的bean，和解析后的bean比较后，得出多出来的bean
                Set<String> oldCandidateNames = new HashSet(Arrays.asList(candidateNames));
                
                //设置alreadyParsedClasses
                Set<String> alreadyParsedClasses = new HashSet();
                Iterator var12 = alreadyParsed.iterator();
                while(var12.hasNext()) {
                    ConfigurationClass configurationClass = (ConfigurationClass)var12.next();
                    alreadyParsedClasses.add(configurationClass.getMetadata().getClassName());
                }
				
                //遍历所有的现有的BeanDefinitionNames
                //如果不是旧的oldCandidateNames且没有解析过，加入candidates
                String[] var23 = newCandidateNames;
                int var24 = newCandidateNames.length;
                for(int var14 = 0; var14 < var24; ++var14) {
                    String candidateName = var23[var14];
                    //过滤出解析后得出来的新bean，加入下一轮的candidates
                    if (!oldCandidateNames.contains(candidateName)) {
                        BeanDefinition bd = registry.getBeanDefinition(candidateName);
                        //加入下一轮的candidates
                        if (ConfigurationClassUtils.checkConfigurationClassCandidate(bd, this.metadataReaderFactory) && !alreadyParsedClasses.contains(bd.getBeanClassName())) {
                            candidates.add(new BeanDefinitionHolder(bd, candidateName));
                        }
                    }
                }

                candidateNames = newCandidateNames;//设置下一轮解析前的bean为这一轮解析后的bean
            }
            //关键：直到没有新的加入的candidates时才结束（即没有递归了）
        } while(!candidates.isEmpty());

        //sbr = (SingletonBeanRegistry)registry;，如果sbr中不存在IMPORT_REGISTRY_BEAN_NAME，注册一个
        if (sbr != null && !sbr.containsSingleton(IMPORT_REGISTRY_BEAN_NAME)) {
            sbr.registerSingleton(IMPORT_REGISTRY_BEAN_NAME, parser.getImportRegistry());
        }
        //清除缓存
        if (this.metadataReaderFactory instanceof CachingMetadataReaderFactory) {
            ((CachingMetadataReaderFactory)this.metadataReaderFactory).clearCache();
        }

    }
}
```
## 3.1 判断bean是否为配置类，如果是设置Order属性并加入configCandidates

- 获取类名,如果类名不存在则返回false
- 如果存在，则获取MetaData
  -  如果BeanDefinition 是 AnnotatedBeanDefinition的实例,并且className 和 BeanDefinition中 的元数据 的类名相同则直接从BeanDefinition 获得Metadata
  - 如果BeanDefinition 是 AnnotatedBeanDefinition的实例,并且beanDef 有 beanClass 属性存在 则实例化StandardAnnotationMetadata
  - 否则 通过MetadataReaderFactory 中的MetadataReader 进行读取
- 判断MetaData有没有Configuration 注解
  - 如果存在Configuration 注解,则为BeanDefinition 设置configurationClass属性为full
  - 如果AnnotationMetadata 中有Component,ComponentScan,Import,ImportResource 注解中的任意一个,或者存在 被@bean 注解的方法,.则设置configurationClass属性为lite
  - 否则直接返回
- 判断MetaData中有没有Order注解，如果有则设置order属性为@Order的值
- 走到这里返回true，说明是配置类，否则返回false

```java
public static boolean checkConfigurationClassCandidate(BeanDefinition beanDef, MetadataReaderFactory metadataReaderFactory) {
    // ----获取类名,如果类名不存在则返回false
    String className = beanDef.getBeanClassName();
    if (className != null && beanDef.getFactoryMethodName() == null) {
        Object metadata;
        if (beanDef instanceof AnnotatedBeanDefinition && className.equals(((AnnotatedBeanDefinition)beanDef).getMetadata().getClassName())) {
            // ----如果BeanDefinition 是 AnnotatedBeanDefinition的实例,并且className 和 BeanDefinition中 的元数据 的类名相同则直接从BeanDefinition 获得Metadata
            metadata = ((AnnotatedBeanDefinition)beanDef).getMetadata();
        } else if (beanDef instanceof AbstractBeanDefinition && ((AbstractBeanDefinition)beanDef).hasBeanClass()) {
            // ----如果BeanDefinition 是 AnnotatedBeanDefinition的实例,并且beanDef 有 beanClass 属性存在 则实例化StandardAnnotationMetadata
            Class<?> beanClass = ((AbstractBeanDefinition)beanDef).getBeanClass();
            metadata = new StandardAnnotationMetadata(beanClass, true);
        } else {
            // ----否则 通过MetadataReaderFactory 中的MetadataReader 进行读取
            try {
                MetadataReader metadataReader = metadataReaderFactory.getMetadataReader(className);
                metadata = metadataReader.getAnnotationMetadata();
            } catch (IOException var5) {
                if (logger.isDebugEnabled()) {
                    logger.debug("Could not find class file for introspecting configuration annotations: " + className, var5);
                }

                return false;
            }
        }
		//
        if (isFullConfigurationCandidate((AnnotationMetadata)metadata)) {
            // ----如果存在Configuration 注解,则为BeanDefinition 设置configurationClass属性为full
            beanDef.setAttribute(CONFIGURATION_CLASS_ATTRIBUTE, "full");
        } else {
            if (!isLiteConfigurationCandidate((AnnotationMetadata)metadata)) {
                return false;
            }
			// ----如果AnnotationMetadata 中有Component,ComponentScan,Import,ImportResource 注解中的任意一个,或者存在 被@bean 注解的方法,则返回true.则设置configurationClass属性为lite
            beanDef.setAttribute(CONFIGURATION_CLASS_ATTRIBUTE, "lite");
        }
        Integer order = getOrder((AnnotationMetadata)metadata);
        if (order != null) {
             // ----如果该类被@Order所注解,则设置order属性为@Order的值
            beanDef.setAttribute(ORDER_ATTRIBUTE, order);
        }
        return true;
    } else {
        return false;
    }
}
```
## 3.2 对configCandidates解析

```java
//ConfigurationClassParser
public void parse(Set<BeanDefinitionHolder> configCandidates) {
    Iterator var2 = configCandidates.iterator();

    while(var2.hasNext()) {
        BeanDefinitionHolder holder = (BeanDefinitionHolder)var2.next();
        BeanDefinition bd = holder.getBeanDefinition();

        try {
            if (bd instanceof AnnotatedBeanDefinition) {
                //3.2.1 main对应的类走这里，我的程序没有走下面两个分支的
                this.parse(((AnnotatedBeanDefinition)bd).getMetadata(), holder.getBeanName());
            } else if (bd instanceof AbstractBeanDefinition && ((AbstractBeanDefinition)bd).hasBeanClass()) {
                this.parse(((AbstractBeanDefinition)bd).getBeanClass(), holder.getBeanName());
            } else {
                this.parse(bd.getBeanClassName(), holder.getBeanName());
            }
        } catch (BeanDefinitionStoreException var6) {
            throw var6;
        } catch (Throwable var7) {
            throw new BeanDefinitionStoreException("Failed to parse configuration class [" + bd.getBeanClassName() + "]", var7);
        }
    }
	//3.2.2 处理deferredImportSelect---一般为AutoConfiguration类中的import内类
    //在这之前，configurationClasses里只有简单的几个业务扫描得到的bean
    //这个完了之后，很多autoconfiguration bean 加入了 configurationClasses
    this.deferredImportSelectorHandler.process();
}
```

### 3.2.1 解析

- 判断类是否应该跳过
  - 如果类被Conditional注解，且matches方法不匹配，则不解析这个类，跳过
  - 将configclass包装成SourceClass
  - 递归调用进行解析

```java
//ConfigurationClassParser
protected void processConfigurationClass(ConfigurationClass configClass) throws IOException {
    // 1. 如果类被Conditional注解，且matches方法不匹配，则不解析这个类，跳过
    //这个if一直到最后
    //3.2.1.1
    if (!this.conditionEvaluator.shouldSkip(configClass.getMetadata(), ConfigurationPhase.PARSE_CONFIGURATION)) {
        // ------ 待分析，第一个main不走
        //这个map 的key==value呀，如果存在的话，证明这个configClass已经解析了，直接返回
        ConfigurationClass existingClass = (ConfigurationClass)this.configurationClasses.get(configClass);
        if (existingClass != null) {
            if (configClass.isImported()) {
                if (existingClass.isImported()) {
                    existingClass.mergeImportedBy(configClass);
                }
                return;
            }
            this.configurationClasses.remove(configClass);
            this.knownSuperclasses.values().removeIf(configClass::equals);
        }

        // -----将configclass包装成SourceClass
        ConfigurationClassParser.SourceClass sourceClass = this.asSourceClass(configClass);
        
        // 3. 递归调用进行解析
        do {
            //3.2.1.2
            sourceClass = this.doProcessConfigurationClass(configClass, sourceClass);
        } while(sourceClass != null);
		
        this.configurationClasses.put(configClass, configClass);
    }
}
```

#### 3.2.1.1 如果类被Conditional注解，且matches方法不匹配，则不解析这个类，跳过

- 如果metadata为null返回false
- 如果metadata没有Conditional返回false
- 如果有Conditional
  - 获取所有的Conditional，并按Order排序
  - 调用所有的Conditional.matches方法，如果有一个不匹配返回true，表示要跳过不解析

```java
//ConditionEvaluator
public boolean shouldSkip(@Nullable AnnotatedTypeMetadata metadata, @Nullable ConfigurationPhase phase) {
    //如果metadata为null返回false，如果metadata没有Conditional返回false
    if (metadata != null && metadata.isAnnotated(Conditional.class.getName())) {
        if (phase == null) {
            //是配置类的话直接使用PARSE_CONFIGURATION阶段
            //否则使用REGISTER_BEAN阶段
            return metadata instanceof AnnotationMetadata && ConfigurationClassUtils.isConfigurationCandidate((AnnotationMetadata)metadata) ? this.shouldSkip(metadata, ConfigurationPhase.PARSE_CONFIGURATION) : this.shouldSkip(metadata, ConfigurationPhase.REGISTER_BEAN);
        } else {
            //phase不为null
            List<Condition> conditions = new ArrayList();
            // 3. 获取配置类的条件注解得到条件数据，并添加到集合中
            Iterator var4 = this.getConditionClasses(metadata).iterator();
            while(var4.hasNext()) {
                String[] conditionClasses = (String[])var4.next();
                String[] var6 = conditionClasses;
                int var7 = conditionClasses.length;

                for(int var8 = 0; var8 < var7; ++var8) {
                    String conditionClass = var6[var8];
                    Condition condition = this.getCondition(conditionClass, this.context.getClassLoader());
                    conditions.add(condition);
                }
            }
		   //根据Order排序
            AnnotationAwareOrderComparator.sort(conditions);
            
            // 4. 遍历conditions,进行判断
            var4 = conditions.iterator();
            Condition condition;
            ConfigurationPhase requiredPhase;
            do {
                do {
                    //iterator要判断是否有值了
                    if (!var4.hasNext()) {
                        return false;
                    }
                    condition = (Condition)var4.next();
                    requiredPhase = null;
                    if (condition instanceof ConfigurationCondition) {
                        requiredPhase = ((ConfigurationCondition)condition).getConfigurationPhase();
                    }
                } while(requiredPhase != null && requiredPhase != phase);
            } while(condition.matches(this.context, metadata));//不匹配，返回true
            return true;
        }
    } else {
        return false;
    }
}
```

#### 3.2.1.2 没有被Conditional注解，或者匹配，则递归调用进行解析—这里真正的按步骤解析

```java
//ConfigurationClassParser
protected final ConfigurationClassParser.SourceClass doProcessConfigurationClass(ConfigurationClass configClass, ConfigurationClassParser.SourceClass sourceClass) throws IOException {
    if (configClass.getMetadata().isAnnotated(Component.class.getName())) {
        //3.2.1.2.1 递归解析类中的内部类
        this.processMemberClasses(configClass, sourceClass);
    }

    // 查找该类有没有@PropertySources注解,有的话做处理
    // 3.2.1.2.2 查找该参数在类及其父类找中对应的注解
    Iterator var3 = AnnotationConfigUtils.attributesForRepeatable(sourceClass.getMetadata(), PropertySources.class, PropertySource.class).iterator();
    AnnotationAttributes importResource;
    while(var3.hasNext()) {
        importResource = (AnnotationAttributes)var3.next();
        if (this.environment instanceof ConfigurableEnvironment) {
            //3.2.1.2.3 处理@PropertySources注解
            this.processPropertySource(importResource);
        } else {
            this.logger.info("Ignoring @PropertySource annotation on [" + sourceClass.getMetadata().getClassName() + "]. Reason: Environment must implement ConfigurableEnvironment");
        }
    }

    //处理@ComponentScan/s,@ComponentScan找到了
    Set<AnnotationAttributes> componentScans = AnnotationConfigUtils.attributesForRepeatable(sourceClass.getMetadata(), ComponentScans.class, ComponentScan.class);
    if (!componentScans.isEmpty() && !this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {
        Iterator var13 = componentScans.iterator();

        while(var13.hasNext()) {
            AnnotationAttributes componentScan = (AnnotationAttributes)var13.next();
            //3.2.1.2.4解析basePackages并扫描，这里扫描出了PersonController/personServiceImpl
            Set<BeanDefinitionHolder> scannedBeanDefinitions = this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());
            Iterator var7 = scannedBeanDefinitions.iterator();

            while(var7.hasNext()) {
                BeanDefinitionHolder holder = (BeanDefinitionHolder)var7.next();
                BeanDefinition bdCand = holder.getBeanDefinition().getOriginatingBeanDefinition();
                if (bdCand == null) {
                    bdCand = holder.getBeanDefinition();
                }
			   //检测是否已经解析
                if (ConfigurationClassUtils.checkConfigurationClassCandidate(bdCand, this.metadataReaderFactory)) {
                    //3.2.1.2.5 递归解析：回到3.2.1进行解析，但还是在3之内！
                    this.parse(bdCand.getBeanClassName(), holder.getBeanName());
                }
            }
        }
    }

    //处理@Import
    //3.2.1.2.6 处理Import注解
    this.processImports(configClass, sourceClass, this.getImports(sourceClass), true);
    
    //处理@ImportResource：@ImportResource(“classpath:config.xml”)，加入当前类的ImportedResource中，留待以后处理
    importResource = AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class);
    if (importResource != null) {
        // 遍历配置的locations,加入到configClass 中的ImportedResource
        String[] resources = importResource.getStringArray("locations");
        Class<? extends BeanDefinitionReader> readerClass = importResource.getClass("reader");
        String[] var19 = resources;
        int var21 = resources.length;

        for(int var22 = 0; var22 < var21; ++var22) {
            String resource = var19[var22];
            String resolvedResource = this.environment.resolveRequiredPlaceholders(resource);
            configClass.addImportedResource(resolvedResource, readerClass);
        }
    }
	
    //处理@Bean注解：获取类内部被@Bean注解修饰的方法，然后添加到配置类的beanMethods属性中
    //3.2.1.2.7
    Set<MethodMetadata> beanMethods = this.retrieveBeanMethodMetadata(sourceClass);
    Iterator var17 = beanMethods.iterator();
    while(var17.hasNext()) {
        MethodMetadata methodMetadata = (MethodMetadata)var17.next();
        configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));
    }
	//接口
    //3.2.1.2.9
    this.processInterfaces(configClass, sourceClass);
    
    //如果有父类的话,则返回父类进行进一步的解析
    if (sourceClass.getMetadata().hasSuperClass()) {
        String superclass = sourceClass.getMetadata().getSuperClassName();
        if (superclass != null && !superclass.startsWith("java") && !this.knownSuperclasses.containsKey(superclass)) {
            this.knownSuperclasses.put(superclass, configClass);
            return sourceClass.getSuperClass();//return不为null，则不跳过最外层的循环，继续解析父类！
        }
    }

    return null;//走到这里，才跳过外层循环
}
```

##### 3.2.1.2.1 processMemberClasses（递归解析内部类，这里可能出现内部类和外部类的循环依赖）

- 遍历class中的内部类
- 如果importStack 包含该configClass的话,则意味发生了循环依赖,则会抛出BeanDefinitionParsingException 异常
- 否则加入到importStack
- 调用processConfigurationClass 进行解析，3.2.1 解析（递归了）

```java
//ConfigurationClassParser
private void processMemberClasses(ConfigurationClass configClass, ConfigurationClassParser.SourceClass sourceClass) throws IOException {
    //返回类中定义的公共、私有、保护的内部类
    Collection<ConfigurationClassParser.SourceClass> memberClasses = sourceClass.getMemberClasses();
    if (!memberClasses.isEmpty()) {
        List<ConfigurationClassParser.SourceClass> candidates = new ArrayList(memberClasses.size());
        // 1. 遍历class中的内部类
        Iterator var5 = memberClasses.iterator();
        ConfigurationClassParser.SourceClass candidate;
        while(var5.hasNext()) {
            candidate = (ConfigurationClassParser.SourceClass)var5.next();
            // 2. 如果该内部类是一个配置类,并且该内部类的类名和configClass的类名不相同
            if (ConfigurationClassUtils.isConfigurationCandidate(candidate.getMetadata()) && !candidate.getMetadata().getClassName().equals(configClass.getMetadata().getClassName())) {
                candidates.add(candidate);
            }
        }
		//按Order排序
        OrderComparator.sort(candidates);
        //遍历候选的
        var5 = candidates.iterator();
        while(var5.hasNext()) {
            candidate = (ConfigurationClassParser.SourceClass)var5.next();
            // 2.1 如果importStack 包含该configClass的话,则意味发生了循环依赖,则会抛出BeanDefinitionParsingException 异常
            if (this.importStack.contains(configClass)) {
                this.problemReporter.error(new ConfigurationClassParser.CircularImportProblem(configClass, this.importStack));
            } else {
                //否则加入到importStack
                this.importStack.push(configClass);
                try {
                    //2.2调用processConfigurationClass 进行解析，3.2.1 解析（递归了）
                    //递归push，当importStack有值时，肯定发生循环依赖
                    this.processConfigurationClass(candidate.asConfigClass(configClass));
                } finally {
                    this.importStack.pop();//最后递归pop
                }
            }
        }
    }
}
```

##### 3.2.1.2.2 查找该参数在类及其父类找中对应的注解-这是一个很不错的通用方法-在annotationConfigUtils中

- 在annotationConfigUtils中

```java
AnnotationConfigUtils.attributesForRepeatable(sourceClass.getMetadata(), PropertySources.class, PropertySource.class)；

    static Set<AnnotationAttributes> attributesForRepeatable(AnnotationMetadata metadata, String containerClassName, String annotationClassName) {
        Set<AnnotationAttributes> result = new LinkedHashSet();
        //添加propertySource注解资源
        addAttributesIfNotNull(result, metadata.getAnnotationAttributes(annotationClassName, false));
        //添加PropertySources的多个资源
        Map<String, Object> container = metadata.getAnnotationAttributes(containerClassName, false);
        if (container != null && container.containsKey("value")) {
            Map[] var5 = (Map[])((Map[])container.get("value"));
            int var6 = var5.length;

            for(int var7 = 0; var7 < var6; ++var7) {
                Map<String, Object> containedAttributes = var5[var7];
                addAttributesIfNotNull(result, containedAttributes);
            }
        }

        return Collections.unmodifiableSet(result);
    }
    
//关键方法：
searchWithGetSemantics(...);
searchWithGetSemanticsInAnnotations();
```

##### 3.2.1.2.3 处理@PropertySource注解

- 解析name,encoding,locations,ignoreResourceNotFound
- 解析factory,用来根据前面的解析值创建propertySource
- 对location进行SPEL表达式的解析
- 将资源加入environment中的propertySource中

```java
private void processPropertySource(AnnotationAttributes propertySource) throws IOException {
    //解析name
    String name = propertySource.getString("name");
    if (!StringUtils.hasLength(name)) {
        name = null;
    }
    //解析encoding
    String encoding = propertySource.getString("encoding");
    if (!StringUtils.hasLength(encoding)) {
        encoding = null;
    }
	//解析路径
    String[] locations = propertySource.getStringArray("value");
    Assert.isTrue(locations.length > 0, "At least one @PropertySource(value) location is required");
    //解析ignoreResourceNotFound属性，如果为true，找不到资源不报错
    boolean ignoreResourceNotFound = propertySource.getBoolean("ignoreResourceNotFound");
    
    //解析factory,用来根据前面的解析值创建propertySource
    Class<? extends PropertySourceFactory> factoryClass = propertySource.getClass("factory");
    //如果该值没有配置，默认为PropertySourceFactory则直接实例化DefaultPropertySourceFactory类，否则开始实例化自定义的类
    PropertySourceFactory factory = factoryClass == PropertySourceFactory.class ? DEFAULT_PROPERTY_SOURCE_FACTORY : (PropertySourceFactory)BeanUtils.instantiateClass(factoryClass);
    
    //遍历路径
    String[] var8 = locations;
    int var9 = locations.length;
    for(int var10 = 0; var10 < var9; ++var10) {
        String location = var8[var10];
        try {
            //对location进行SPEL表达式的解析。比如当前的配置环境中有一个属性为app=shareniu，我们配置的location为${app}最终值为shareniu。通过这里的处理逻辑可以知道location支持多环境的切换以及表达式的配置
            String resolvedLocation = this.environment.resolveRequiredPlaceholders(location);
            //加载资源
            Resource resource = this.resourceLoader.getResource(resolvedLocation);
            //将资源加入environment中的propertySource中！！
            this.addPropertySource(factory.createPropertySource(name, new EncodedResource(resource, encoding)));
        } catch (FileNotFoundException | UnknownHostException | IllegalArgumentException var14) {
            //如果为true，找不到资源不报错
            if (!ignoreResourceNotFound) {
                throw var14;
            }
            if (this.logger.isInfoEnabled()) {
                this.logger.info("Properties location [" + location + "] not resolvable: " + var14.getMessage());
            }
        }
    }
}
```

##### 3.2.1.2.4 扫描basePackages，得到其下的类

###### 3.2.1.2.4.1 注册Scanner，并从@Component注解中添加信息到Scanner中，为扫描做准备

- 注册扫描器Scanner
- 获取BeanNameGenerator，一般是内置的，也可以在注解中指定自定义的BeanNameGenerator
- 将BeanNameGenerator注入到Scanner中
- 获取注解的扫描范围，一般是默认的，加入到Scanner中
- 获取excludeFilter并加入Scanner，默认有两个：TypeExcludeFilter，AutoConfigurationExcludeFilter
- 获取lazyInit，默认为false，加入Scanner中
- 获取扫描的包，默认为当前包路径
- **又添加了一个遍历层次结构的过滤器-目标类名要和当前名字一样**

```java
public Set<BeanDefinitionHolder> parse(AnnotationAttributes componentScan, final String declaringClass) {
    //注册扫描器
    ClassPathBeanDefinitionScanner scanner = new ClassPathBeanDefinitionScanner(this.registry, componentScan.getBoolean("useDefaultFilters"), this.environment, this.resourceLoader);
    //获取nameGenerator：一般是内置的BeanNameGenerator，也可以自定义（在@ComponentScan注解中指定）
    Class<? extends BeanNameGenerator> generatorClass = componentScan.getClass("nameGenerator");
    boolean useInheritedGenerator = BeanNameGenerator.class == generatorClass;
    scanner.setBeanNameGenerator(useInheritedGenerator ? this.beanNameGenerator : (BeanNameGenerator)BeanUtils.instantiateClass(generatorClass));
    //一般为默认
    ScopedProxyMode scopedProxyMode = (ScopedProxyMode)componentScan.getEnum("scopedProxy");
    if (scopedProxyMode != ScopedProxyMode.DEFAULT) {
        scanner.setScopedProxyMode(scopedProxyMode);
    } else {
        Class<? extends ScopeMetadataResolver> resolverClass = componentScan.getClass("scopeResolver");
        scanner.setScopeMetadataResolver((ScopeMetadataResolver)BeanUtils.instantiateClass(resolverClass));
    }
	//设置resourcePattern
    scanner.setResourcePattern(componentScan.getString("resourcePattern"));
    //设置includeFilters
    AnnotationAttributes[] var15 = componentScan.getAnnotationArray("includeFilters");
    int var8 = var15.length;

    int var9;
    AnnotationAttributes filter;
    Iterator var11;
    TypeFilter typeFilter;
    for(var9 = 0; var9 < var8; ++var9) {
        filter = var15[var9];
        var11 = this.typeFiltersFor(filter).iterator();

        while(var11.hasNext()) {
            typeFilter = (TypeFilter)var11.next();
            scanner.addIncludeFilter(typeFilter);
        }
    }
	//设置excludeFilters：默认有两个：TypeExcludeFilter，AutoConfigurationExcludeFilter
    var15 = componentScan.getAnnotationArray("excludeFilters");
    var8 = var15.length;

    for(var9 = 0; var9 < var8; ++var9) {
        filter = var15[var9];
        var11 = this.typeFiltersFor(filter).iterator();

        while(var11.hasNext()) {
            typeFilter = (TypeFilter)var11.next();
            scanner.addExcludeFilter(typeFilter);
        }
    }
	//lazyInit
    boolean lazyInit = componentScan.getBoolean("lazyInit");
    if (lazyInit) {
        scanner.getBeanDefinitionDefaults().setLazyInit(true);
    }
	//扫描包路径：默认当前路径
    Set<String> basePackages = new LinkedHashSet();
    String[] basePackagesArray = componentScan.getStringArray("basePackages");
    String[] var19 = basePackagesArray;
    int var21 = basePackagesArray.length;

    int var22;
    for(var22 = 0; var22 < var21; ++var22) {
        String pkg = var19[var22];
        String[] tokenized = StringUtils.tokenizeToStringArray(this.environment.resolvePlaceholders(pkg), ",; \t\n");
        Collections.addAll(basePackages, tokenized);
    }

    Class[] var20 = componentScan.getClassArray("basePackageClasses");
    var21 = var20.length;

    for(var22 = 0; var22 < var21; ++var22) {
        Class<?> clazz = var20[var22];
        basePackages.add(ClassUtils.getPackageName(clazz));
    }

    if (basePackages.isEmpty()) {
        basePackages.add(ClassUtils.getPackageName(declaringClass));
    }
	//添加一个ExcludeFilter
    scanner.addExcludeFilter(new AbstractTypeHierarchyTraversingFilter(false, false) {
        protected boolean matchClassName(String className) {
            return declaringClass.equals(className);
        }
    });
    //开始扫描
    return scanner.doScan(StringUtils.toStringArray(basePackages));
}
```

###### 3.2.1.2.4.2 开始扫描,带入的是默认的当前包路径

- 遍历basePackages,通过findCandidateComponents方法扫描basePackage路径下的java文件
- 如果扫描到文件的话,则遍历之 
  - 解析scope属性：singleton等
  - 生成beanName 
  - 如果该 BeanDefinition 是AbstractBeanDefinition 的子类的话,则调用postProcessBeanDefinition为其设置默认值 
  - 如果该BeanDefinition是AnnotatedBeanDefinition的子类,则调用AnnotationConfigUtils#processCommonDefinitionAnnotations,检查常用注解:如lazy等
  - 检查当前bean是否已经注册,如果没有注册的话,则 
    - 生成BeanDefinitionHolder
    - 如果当前bean是用于生成代理的bean那么需要进一步处理 
    - **添加到beanDefinitions中-这里就多了一个bean了**
    - 向BeanDefinitionRegistry进行注册
- 依次遍历扫描的配置类进行递归解析.最终又会调用ConfigurationClassParser#processConfigurationClass

```java
//ClassPathBeanDefinitionScanner
//basePackages一般默认为当前路径
protected Set<BeanDefinitionHolder> doScan(String... basePackages) {
    Assert.notEmpty(basePackages, "At least one base package must be specified");
    Set<BeanDefinitionHolder> beanDefinitions = new LinkedHashSet();
    String[] var3 = basePackages;
    int var4 = basePackages.length;

    for(int var5 = 0; var5 < var4; ++var5) {
        String basePackage = var3[var5];
        //找到basePackage下的类：personController,personServiceImpl
        //3.2.1.2.3.1
        Set<BeanDefinition> candidates = this.findCandidateComponents(basePackage);
        Iterator var8 = candidates.iterator();
        while(var8.hasNext()) {
            BeanDefinition candidate = (BeanDefinition)var8.next();
            // 解析scope属性：一般为singleton
            ScopeMetadata scopeMetadata = this.scopeMetadataResolver.resolveScopeMetadata(candidate);
            candidate.setScope(scopeMetadata.getScopeName());
            //beanNameGenerator生成BeanName
            String beanName = this.beanNameGenerator.generateBeanName(candidate, this.registry);
            // 普通的BeanDefinition
            if (candidate instanceof AbstractBeanDefinition) {
                //设置candidate的beanDefinition的默认属性：isLazyInit、getAutowireMode等
                this.postProcessBeanDefinition((AbstractBeanDefinition)candidate, beanName);
            }
             // 注解的BeanDefinition，处理注解@Primary、@DependsOn等Bean注解
			//如果是AnnotatedBeanDefinition类型,设置正真属性：setLazyInit、setPrimary、setDependsOn等
            if (candidate instanceof AnnotatedBeanDefinition) {
                AnnotationConfigUtils.processCommonDefinitionAnnotations((AnnotatedBeanDefinition)candidate);
            }
 			// 检查当前bean是否已经注册（BeanFactory中是否包含此BeanDefinition）
            if (this.checkCandidate(beanName, candidate)) {
                //如果没有
                BeanDefinitionHolder definitionHolder = new BeanDefinitionHolder(candidate, beanName);
                //如果当前bean是用于生成代理的bean那么需要进一步处理
                definitionHolder = AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, this.registry);
                //加入beanDefinitions
                beanDefinitions.add(definitionHolder);
                //将beanDefinition信息注册到相关map中
                this.registerBeanDefinition(definitionHolder, this.registry);
            }
        }
    }
    return beanDefinitions;
}
```

###### 3.2.1.2.4.2-1 找到包下的beanDefinition：默认路径为'classpath\*:\*\*/\*.class'

```java
//ClassPathScanningCandidateComponentProvider
private Set<BeanDefinition> scanCandidateComponents(String basePackage) {
    // 创建存储扫描到的类的集合
    LinkedHashSet candidates = new LinkedHashSet();

    try {
        // 默认的包路径：this.resourcePattern=” **/*.class”，  
        // resolveBasePackage方法将包名中的”.”转换为文件系统的”/”
        String packageSearchPath = "classpath*:" + this.resolveBasePackage(basePackage) + '/' + this.resourcePattern;
        // 循环获取到的资源文件
        Resource[] resources = this.getResourcePatternResolver().getResources(packageSearchPath);
        boolean traceEnabled = this.logger.isTraceEnabled();
        boolean debugEnabled = this.logger.isDebugEnabled();
        Resource[] var7 = resources;
        int var8 = resources.length;
        for(int var9 = 0; var9 < var8; ++var9) {
            Resource resource = var7[var9];
            if (traceEnabled) {
                this.logger.trace("Scanning " + resource);
            }
            if (resource.isReadable()) {
                try {
                    //为指定资源获取元数据读取器，元信息读取器通过汇编(ASM)读//取资源元信息
                    MetadataReader metadataReader = this.getMetadataReaderFactory().getMetadataReader(resource);
                    //如果扫描到的类符合容器配置的过滤规则  
                    if (this.isCandidateComponent(metadataReader)) {
                        //通过汇编(ASM)读取资源字节码中的Bean定义元信息
                        ScannedGenericBeanDefinition sbd = new ScannedGenericBeanDefinition(metadataReader);
                        //设置Bean定义来源于resource 
                        sbd.setResource(resource);
                        //为元数据元素设置配置资源对象  
                        sbd.setSource(resource);
                        //检查Bean是否是一个可实例化的对象
                        if (this.isCandidateComponent((AnnotatedBeanDefinition)sbd)) {
                            if (debugEnabled) {
                                this.logger.debug("Identified candidate component class: " + resource);
                            }

                            candidates.add(sbd);
                        } else if (debugEnabled) {
                            this.logger.debug("Ignored because not a concrete top-level class: " + resource);
                        }
                    } else if (traceEnabled) {
                        this.logger.trace("Ignored because not matching any filter: " + resource);
                    }
                } catch (Throwable var13) {
                    throw new BeanDefinitionStoreException("Failed to read candidate component class: " + resource, var13);
                }
            } else if (traceEnabled) {
                this.logger.trace("Ignored because not readable: " + resource);
            }
        }
        return candidates;
    } catch (IOException var14) {
        throw new BeanDefinitionStoreException("I/O failure during classpath scanning", var14);
    }
}
```

##### 3.2.1.2.5 递归解析：回到3.2.1进行解析，但还是在3之内！

```java
//ConfigurationClassParser
protected final void parse(@Nullable String className, String beanName) throws IOException {
    Assert.notNull(className, "No bean class name for configuration class bean definition");
    MetadataReader reader = this.metadataReaderFactory.getMetadataReader(className);
    //3.2.1 递归解析该类（将personController又看成main对应的类）
    this.processConfigurationClass(new ConfigurationClass(reader, beanName));
}
```

##### 3.2.1.2.6 处理目标类中@Import注解-得到所有的Import中的类

```java
//ConfigurationClassParser
this.processImports(configClass, sourceClass, this.getImports(sourceClass), true);
//首先调用getImports返回目标类中所有的@import注解属性
//然后处理目标类的所有@import注解
```

###### 3.2.1.2.6.1 递归得到所有@import注解中的类

- 比如，@SpringBootApplication注解的@Import注解数据的话，首先发现@SpringBootApplication不是一个@Import注解，然后递归调用修饰了@SpringBootApplication的注解，发现有个@EnableAutoConfiguration注解，再次递归发现被@Import(EnableAutoConfigurationImportSelector.class)修饰
- @SpringBootApplication注解有两个@import注解
  - @Import(AutoConfigurationPackages.Registrar.class) 
  - @Import(EnableAutoConfigurationImportSelector.class) 

```java
//ConfigurationClassParser
//通过getImports(sourceClass)获取Configuration类中使用Import注解的类
private Set<ConfigurationClassParser.SourceClass> getImports(ConfigurationClassParser.SourceClass sourceClass) throws IOException {
    Set<ConfigurationClassParser.SourceClass> imports = new LinkedHashSet();
    Set<ConfigurationClassParser.SourceClass> visited = new LinkedHashSet();
    this.collectImports(sourceClass, imports, visited);
    return imports;//imports.addAll返回了所有的
}
//ConfigurationClassParser
private void collectImports(ConfigurationClassParser.SourceClass sourceClass, Set<ConfigurationClassParser.SourceClass> imports, Set<ConfigurationClassParser.SourceClass> visited) throws IOException {
    if (visited.add(sourceClass)) {
        //得到注解
        Iterator var4 = sourceClass.getAnnotations().iterator();

        while(var4.hasNext()) {
            ConfigurationClassParser.SourceClass annotation = (ConfigurationClassParser.SourceClass)var4.next();
            String annName = annotation.getMetadata().getClassName();
            if (!annName.startsWith("java") && !annName.equals(Import.class.getName())) {
                //递归处理注解的注解！
                this.collectImports(annotation, imports, visited);
            }
        }
        //所有@import中用到的类都加入
        imports.addAll(sourceClass.getAnnotationAttributes(Import.class.getName(), "value"));
    }

}
```

###### 3.2.1.2.6.2 处理上一步得到的所有Import中的类-递归解析，最后把其中的配置类当作configClass来处理

- @Import可以引入普通类、Configuration类、ImportBeanDefinitionRegistrar和ImportSelector的实例，不排斥这些类中也包含Import，所以方法中也包含一个processConfigurationClass递归。 
- ImportSelector和ImportBeanDefinitionRegistrar是Spring中两个扩展接口，分别通过selectImports方法和registerBeanDefinitions方法向容器注入Bean。 
- 另外ImportSelector还有一个子接口DeferredImportSelectors，这 个接口的实现类会等到Configuration类解析完之后在进行再进行processImports处理。 

```java
private void processImports(ConfigurationClass configClass, ConfigurationClassParser.SourceClass currentSourceClass, Collection<ConfigurationClassParser.SourceClass> importCandidates, boolean checkForCircularImports) {
    //这个if直到最后
    if (!importCandidates.isEmpty()) {
        //循环Import依赖，checkForCircularImports默认为true
        if (checkForCircularImports && this.isChainedImportOnStack(configClass)) {
            this.problemReporter.error(new ConfigurationClassParser.CircularImportProblem(configClass, this.importStack));
        } else {
            this.importStack.push(configClass);//将Import注解的目标类放入栈中
			//遍历这些@Import注解内部的属性类集合ComponentScanAnnotationParser
            try {
                Iterator var5 = importCandidates.iterator();

                while(var5.hasNext()) {
                    ConfigurationClassParser.SourceClass candidate = (ConfigurationClassParser.SourceClass)var5.next();
                    Class candidateClass;
                    //如果这个类是个ImportSelector接口的实现类
                    if (candidate.isAssignable(ImportSelector.class)) {
                        candidateClass = candidate.loadClass();
                        // 实例化这个ImportSelector
                        ImportSelector selector = (ImportSelector)BeanUtils.instantiateClass(candidateClass, ImportSelector.class);
                        //这是干啥：
                        ParserStrategyUtils.invokeAwareMethods(selector, this.environment, this.resourceLoader, this.registry);
                        // 如果这个类也是DeferredImportSelector接口的实现类，留到后面处理
                        // 那么加入ConfigurationClassParser的deferredImportSelectors
                        if (selector instanceof DeferredImportSelector) {
                            this.deferredImportSelectorHandler.handle(configClass, (DeferredImportSelector)selector);
                        } else {
                            // 否则调用ImportSelector的selectImports方法得到需要Import的类
                        	// 然后对这些类递归做@Import注解的处理
                            String[] importClassNames = selector.selectImports(currentSourceClass.getMetadata());
                            //包装成类
                            Collection<ConfigurationClassParser.SourceClass> importSourceClasses = this.asSourceClasses(importClassNames);
                            //递归解析Import注解
                            this.processImports(configClass, currentSourceClass, importSourceClasses, false);
                        }
                    } 
                    // 如果这个类是ImportBeanDefinitionRegistrar接口的实现类
                	// 设置到配置类的importBeanDefinitionRegistrars属性中
                    else if (candidate.isAssignable(ImportBeanDefinitionRegistrar.class)) {
                        candidateClass = candidate.loadClass();
                        ImportBeanDefinitionRegistrar registrar = (ImportBeanDefinitionRegistrar)BeanUtils.instantiateClass(candidateClass, ImportBeanDefinitionRegistrar.class);
                        ParserStrategyUtils.invokeAwareMethods(registrar, this.environment, this.resourceLoader, this.registry);
                        configClass.addImportBeanDefinitionRegistrar(registrar, currentSourceClass.getMetadata());
                    } else {
                         // 其它情况下把这个类入队到ConfigurationClassParser的importStack(队列)属性中
                    	
                        this.importStack.registerImport(currentSourceClass.getMetadata(), candidate.getMetadata().getClassName());
                        // 然后把这个类当成是@Configuration注解修饰的类递归重头开始解析这个类！！
                        this.processConfigurationClass(candidate.asConfigClass(configClass));
                    }
                }
            } catch (BeanDefinitionStoreException var15) {
                throw var15;
            } catch (Throwable var16) {
                throw new BeanDefinitionStoreException("Failed to process import candidates for configuration class [" + configClass.getMetadata().getClassName() + "]", var16);
            } finally {
                this.importStack.pop();
            }
        }

    }
}
```
##### 3.2.1.2.7 得到类内部被@Bean注解的方法

```java
private Set<MethodMetadata> retrieveBeanMethodMetadata(ConfigurationClassParser.SourceClass sourceClass) {
    AnnotationMetadata original = sourceClass.getMetadata();
    //获取被@Bean注解的方法
    Set<MethodMetadata> beanMethods = original.getAnnotatedMethods(Bean.class.getName());
    //如果有
    if (((Set)beanMethods).size() > 1 && original instanceof StandardAnnotationMetadata) {
        try {
            AnnotationMetadata asm = this.metadataReaderFactory.getMetadataReader(original.getClassName()).getAnnotationMetadata();
            Set<MethodMetadata> asmMethods = asm.getAnnotatedMethods(Bean.class.getName());
            if (asmMethods.size() >= ((Set)beanMethods).size()) {
                Set<MethodMetadata> selectedMethods = new LinkedHashSet(asmMethods.size());
                Iterator var7 = asmMethods.iterator();
				
                while(true) {
                    while(var7.hasNext()) {
                        MethodMetadata asmMethod = (MethodMetadata)var7.next();
                        Iterator var9 = ((Set)beanMethods).iterator();

                        while(var9.hasNext()) {
                            MethodMetadata beanMethod = (MethodMetadata)var9.next();
                            if (beanMethod.getMethodName().equals(asmMethod.getMethodName())) {
                                selectedMethods.add(beanMethod);
                                break;
                            }
                        }
                    }

                    if (selectedMethods.size() == ((Set)beanMethods).size()) {
                        beanMethods = selectedMethods;
                    }
                    break;
                }
            }
        } catch (IOException var11) {
            this.logger.debug("Failed to read class file via ASM for determining @Bean method order", var11);
        }
    }

    return (Set)beanMethods;
}
```

##### 3.2.1.2.8 处理类实现接口的类被@Bean注解的方法

```java
private void processInterfaces(ConfigurationClass configClass, ConfigurationClassParser.SourceClass sourceClass) throws IOException {
    Iterator var3 = sourceClass.getInterfaces().iterator();

    while(var3.hasNext()) {
        ConfigurationClassParser.SourceClass ifc = (ConfigurationClassParser.SourceClass)var3.next();
        //处理@Bean
        Set<MethodMetadata> beanMethods = this.retrieveBeanMethodMetadata(ifc);
        Iterator var6 = beanMethods.iterator();

        while(var6.hasNext()) {
            MethodMetadata methodMetadata = (MethodMetadata)var6.next();
            if (!methodMetadata.isAbstract()) {
                configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));
            }
        }

        this.processInterfaces(configClass, ifc);
    }

}
```

### **3.2.2 处理deferredImports相关的类：一般和AutoConfiguration有关—关键**！

-  处理deferredImportSelect---一般为AutoConfiguration类中的import内类
- 在这之前，configurationClasses里只有简单的几个业务扫描得到的bean//这个完了之后，很多autoconfiguration bean 加入了 configurationClasses
- 在AutoConfigurationImportSelector中的这个方法中，获取了所有可能的自动配置类！！

```java
public void process() {
    //这里有一个：AutoConfigurationImportSelector
    List<ConfigurationClassParser.DeferredImportSelectorHolder> deferredImports = this.deferredImportSelectors;
    this.deferredImportSelectors = null;

    try {
        if (deferredImports != null) {
            ConfigurationClassParser.DeferredImportSelectorGroupingHandler handler = ConfigurationClassParser.this.new DeferredImportSelectorGroupingHandler();
            deferredImports.sort(ConfigurationClassParser.DEFERRED_IMPORT_COMPARATOR);
            //注册
            deferredImports.forEach(handler::register);
            //获取autoconfiguration,有group可能就走group类中的selectImport方法了
            //在这里获取spring.factories中配置
            handler.processGroupImports();
        }
    } finally {
        this.deferredImportSelectors = new ArrayList();
    }

}

public void processGroupImports() {
    Iterator var1 = this.groupings.values().iterator();

    while(var1.hasNext()) {
        ConfigurationClassParser.DeferredImportSelectorGrouping grouping = (ConfigurationClassParser.DeferredImportSelectorGrouping)var1.next();
        grouping.getImports().forEach((entry) -> {
            //这里有30个entry了
            ConfigurationClass configurationClass = (ConfigurationClass)this.configurationClasses.get(entry.getMetadata());

            try {
                //这里继续解析在spring.factoies中的得到的配置类！！！
                ConfigurationClassParser.this.processImports(configurationClass, ConfigurationClassParser.this.asSourceClass(configurationClass), ConfigurationClassParser.this.asSourceClasses(entry.getImportClassName()), false);
            } catch (BeanDefinitionStoreException var4) {
                throw var4;
            } catch (Throwable var5) {
                throw new BeanDefinitionStoreException("Failed to process import candidates for configuration class [" + configurationClass.getMetadata().getClassName() + "]", var5);
            }
        });
    }

}


//在AutoConfigurationImportSelector中的这个方法中，获取了所有可能的自动配置类！！
protected AutoConfigurationImportSelector.AutoConfigurationEntry getAutoConfigurationEntry(AutoConfigurationMetadata autoConfigurationMetadata, AnnotationMetadata annotationMetadata) {
    if (!this.isEnabled(annotationMetadata)) {
        return EMPTY_ENTRY;
    } else {
        AnnotationAttributes attributes = this.getAttributes(annotationMetadata);
        //在spring.factories中加载所有的autoconfiguration类
        List<String> configurations = this.getCandidateConfigurations(annotationMetadata, attributes);
        //去重
        configurations = this.removeDuplicates(configurations);
        //过滤
        Set<String> exclusions = this.getExclusions(annotationMetadata, attributes);
        this.checkExcludedClasses(configurations, exclusions);
        configurations.removeAll(exclusions);
        //这个过滤了绝大多数的配置类
        configurations = this.filter(configurations, autoConfigurationMetadata);
        this.fireAutoConfigurationImportEvents(configurations, exclusions);
        return new AutoConfigurationImportSelector.AutoConfigurationEntry(configurations, exclusions);
    }
}
protected List<String> getCandidateConfigurations(AnnotationMetadata metadata, AnnotationAttributes attributes) {
    //关键！！！！
    List<String> configurations = SpringFactoriesLoader.loadFactoryNames(this.getSpringFactoriesLoaderFactoryClass(), this.getBeanClassLoader());
    Assert.notEmpty(configurations, "No auto configuration classes found in META-INF/spring.factories. If you are using a custom packaging, make sure that file is correct.");
    return configurations;
}
```

## 3.3 将ConfigurationClass注册到BeanDefinitionMap中

- mapper相关的在这里注册了：Searching for mappers annotated with @Mapper
- Creating MapperFactoryBean with name 'personMapper' and 'com.wangkang.mapper.PersonMapper' mapperInterface
- Enabling autowire by type for MapperFactoryBean with name 'personMapper'.

```java
public void loadBeanDefinitions(Set<ConfigurationClass> configurationModel) {
    ConfigurationClassBeanDefinitionReader.TrackedConditionEvaluator trackedConditionEvaluator = new ConfigurationClassBeanDefinitionReader.TrackedConditionEvaluator();
    Iterator var3 = configurationModel.iterator();

    while(var3.hasNext()) {
        ConfigurationClass configClass = (ConfigurationClass)var3.next();
        this.loadBeanDefinitionsForConfigurationClass(configClass, trackedConditionEvaluator);
    }
}
//加载beanDefinition
private void loadBeanDefinitionsForConfigurationClass(ConfigurationClass configClass, ConfigurationClassBeanDefinitionReader.TrackedConditionEvaluator trackedConditionEvaluator) {
    if (trackedConditionEvaluator.shouldSkip(configClass)) {
        String beanName = configClass.getBeanName();
        if (StringUtils.hasLength(beanName) && this.registry.containsBeanDefinition(beanName)) {
            this.registry.removeBeanDefinition(beanName);
        }

        this.importRegistry.removeImportingClass(configClass.getMetadata().getClassName());
    } else {
        //是否被别的类注入
        if (configClass.isImported()) {
            this.registerBeanDefinitionForImportedConfigurationClass(configClass);
        }

        Iterator var3 = configClass.getBeanMethods().iterator();

        while(var3.hasNext()) {
            BeanMethod beanMethod = (BeanMethod)var3.next();
            //如果有@Bean方法，先加载它
            this.loadBeanDefinitionsForBeanMethod(beanMethod);
        }
        //这两个方法都是，调用目标类中的一些注解信息，去做进一步解析的
		//加载ImportedResources，解析其中的Bean，放入beanDefinition中
        this.loadBeanDefinitionsFromImportedResources(configClass.getImportedResources());
        //加载Registrars有关的：MapperScannerRegistrar、AutoConfiguredMapperScanner等
        this.loadBeanDefinitionsFromRegistrars(configClass.getImportBeanDefinitionRegistrars());
    }
}
```

# 3 invokeBeanFactoryPostProcessors-调用一些后置处理器的方法，对所有的beanDefinition做一些处理

```java
private static void invokeBeanFactoryPostProcessors(Collection<? extends BeanFactoryPostProcessor> postProcessors, ConfigurableListableBeanFactory beanFactory) {
    Iterator var2 = postProcessors.iterator();
    while(var2.hasNext()) {
        BeanFactoryPostProcessor postProcessor = (BeanFactoryPostProcessor)var2.next();
        //遍历每个postProcessor：这里只有一个ConfigurationClassPostProcessor中的postProcessBeanFactory方法有计算，其它2个为空
        postProcessor.postProcessBeanFactory(beanFactory);
    }
}
```